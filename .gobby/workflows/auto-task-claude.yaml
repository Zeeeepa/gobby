name: auto-task-claude
description: |
  Parent orchestrator for Claude Code that spawns Gemini workers in worktrees.

  This workflow runs in Claude Code and:
  1. Finds ready tasks using suggest_next_task()
  2. Spawns Gemini workers in isolated git worktrees
  3. Waits for task completion using wait_for_task()
  4. Polls for child messages and handles results
  5. Loops until all session_tasks are complete

  Usage:
    1. Create/claim a parent task via gobby-tasks
    2. Activate this workflow with session_task set to the task ID(s)
    3. Workflow spawns Gemini workers in worktrees for each ready subtask
    4. Waits for completion, collects results, loops
    5. Exits when task tree is complete

version: "1.1"
type: step

variables:
  session_task: null              # Task ID(s) to complete
  premature_stop_max_attempts: 3
  worker_provider: "gemini"
  worker_terminal: "ghostty"
  worker_timeout: 600
  # Note: worker model is defined in the agent definition (meeseeks.yaml), not here

steps:
  - name: find_work
    description: "Find next ready task using suggest_next_task()"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Finding next task.
          Session task: {{ variables.session_task }}

          Call suggest_next_task to find available work:

          mcp__gobby__call_tool(
            server_name="gobby-tasks",
            tool_name="suggest_next_task",
            arguments={"session_id": "<your_session_id>"}
          )

          If a task is returned, proceed to spawn a worker.
          If no tasks are available, check if work is complete.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read
      - Glob
      - Grep

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: wait_for_workers
        when: "mcp_result_is_null('gobby-tasks', 'suggest_next_task')"
      - to: spawn_worker
        when: "mcp_called('gobby-tasks', 'suggest_next_task')"

  - name: wait_for_workers
    description: "No ready tasks - wait for in-progress workers"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: No ready tasks found.

          All tasks are either in progress or blocked. Waiting for workers to complete.

          Poll for messages from child agents:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="poll_messages",
            arguments={"session_id": "<your_session_id>"}
          )

          Then check for newly available tasks.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: find_work
        when: "mcp_called('gobby-agents', 'poll_messages')"

  - name: spawn_worker
    description: "Spawn Gemini worker in worktree"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Spawning Gemini worker in worktree.

          Configuration:
          - Provider: {{ variables.worker_provider }}
          - Terminal: {{ variables.worker_terminal }}

          Spawn the worker with worktree isolation. IMPORTANT: The prompt must tell
          the worker to activate the workflow with the assigned_task_id variable.

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="spawn_agent",
            arguments={
              "prompt": "You are a Gemini worker in an isolated git worktree.\n\nFIRST, activate your workflow by calling:\n\nmcp__gobby__call_tool(\n  server_name=\"gobby-workflows\",\n  tool_name=\"activate_workflow\",\n  arguments={\n    \"name\": \"work-task-gemini\",\n    \"session_id\": \"<your_gobby_session_id>\",\n    \"variables\": {\"assigned_task_id\": \"<TASK_ID>\"}\n  }\n)\n\nReplace <your_gobby_session_id> with your Gobby Session ID (shown at startup).\nReplace <TASK_ID> with the task ID you were assigned.\n\nThe workflow will guide you through: claim → implement → commit → close → report → shutdown.\n\nDo NOT proceed without activating the workflow first.",
              "task_id": "<suggested_task_id>",
              "isolation": "worktree",
              "workflow": "work-task-gemini",
              "provider": "{{ variables.worker_provider }}",
              "terminal": "{{ variables.worker_terminal }}",
              "parent_session_id": "<your_session_id>"
            }
          )

          IMPORTANT: Replace <TASK_ID> in the prompt with the actual task ID from suggest_next_task.

          Track the returned child_session_id and worktree_id for later use.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: wait_for_worker
        when: "mcp_called('gobby-agents', 'spawn_agent')"
      - to: find_work
        when: "mcp_failed('gobby-agents', 'spawn_agent')"

  - name: wait_for_worker
    description: "Wait for task completion"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Waiting for worker to complete.

          Timeout: {{ variables.worker_timeout }} seconds

          Wait for the task to be closed:

          mcp__gobby__call_tool(
            server_name="gobby-tasks",
            tool_name="wait_for_task",
            arguments={
              "task_id": "<task_id_being_worked>",
              "timeout": {{ variables.worker_timeout }}
            }
          )

          The wait returns:
          - completed: true if task reached closed/review status
          - timed_out: true if timeout reached
          - wait_time: how long we waited

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: handle_timeout
        when: "mcp_result_has('gobby-tasks', 'wait_for_task', 'timed_out', true)"
      - to: collect_results
        when: "mcp_called('gobby-tasks', 'wait_for_task')"

  - name: handle_timeout
    description: "Handle worker timeout"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Worker timed out.

          The worker did not complete within the timeout period.

          Poll for any messages from the child:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="poll_messages",
            arguments={"session_id": "<your_session_id>"}
          )

          Check task status and decide whether to retry or escalate.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: find_work
        when: "mcp_called('gobby-agents', 'poll_messages')"

  - name: collect_results
    description: "Poll messages, loop back"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Collecting results from worker.

          Poll for messages from the child:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="poll_messages",
            arguments={"session_id": "<your_session_id>"}
          )

          Review any messages from the child agent.
          Then loop back to find_work for the next task.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: find_work
        when: "mcp_called('gobby-agents', 'poll_messages')"

  - name: complete
    description: "All tasks done"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: All work complete!

          Session task {{ variables.session_task }} and all subtasks are closed.

          The auto-task-claude workflow will now exit.
          You may stop the session or start a new task.

exit_condition: "task_tree_complete(variables.session_task)"

on_premature_stop:
  action: guide_continuation
  message: |
    Task orchestration incomplete. Options:
    1. Continue working: use suggest_next_task() or wait for workers
    2. Stop anyway: use `/g workflows deactivate` to end the workflow first
