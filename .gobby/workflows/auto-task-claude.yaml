name: auto-task-claude
description: |
  Parent orchestrator for Claude Code that spawns Gemini workers in worktrees.

  This workflow runs in Claude Code and:
  1. Finds ready tasks using suggest_next_task()
  2. Spawns Gemini workers in isolated git worktrees
  3. Waits for task completion using wait_for_task()
  4. Polls for child messages and handles results
  5. Loops until all session_tasks are complete

  Usage:
    1. Create/claim a parent task via gobby-tasks
    2. Activate this workflow with session_task set to the task ID(s)
    3. Workflow spawns Gemini workers in worktrees for each ready subtask
    4. Waits for completion, collects results, loops
    5. Exits when task tree is complete

version: "1.1"
type: step

variables:
  session_task: null              # Task ID(s) to complete
  premature_stop_max_attempts: 3
  worker_provider: "gemini"
  worker_model: "gemini-2.5-pro"
  worker_terminal: "ghostty"
  worker_timeout: 600

steps:
  - name: find_work
    description: "Find next ready task using suggest_next_task()"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Finding next task.
          Session task: {{ variables.session_task }}

          Call suggest_next_task to find available work under session_task:

          mcp__gobby__call_tool(
            server_name="gobby-tasks",
            tool_name="suggest_next_task",
            arguments={
              "session_id": "<your_session_id>",
              "parent_task_id": "{{ variables.session_task }}"
            }
          )

          If a task is returned, proceed to spawn a worker.
          If no tasks are available (null result), check if work is complete.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read
      - Glob
      - Grep

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: spawn_worker
        when: "mcp_called('gobby-tasks', 'suggest_next_task')"

  - name: spawn_worker
    description: "Spawn Gemini worker in worktree"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Spawning Gemini worker in worktree.

          Configuration:
          - Provider: {{ variables.worker_provider }}
          - Model: {{ variables.worker_model }}
          - Terminal: {{ variables.worker_terminal }}

          Spawn the worker with worktree isolation and sandbox:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="spawn_agent",
            arguments={
              "prompt": "Complete the assigned task, commit your changes, then close the task. Send your results to the parent via send_to_parent.",
              "task_id": "<suggested_task_id>",
              "isolation": "worktree",
              "workflow": "work-task-gemini",
              "provider": "{{ variables.worker_provider }}",
              "model": "{{ variables.worker_model }}",
              "terminal": "{{ variables.worker_terminal }}",
              "parent_session_id": "<your_session_id>",
              "sandbox": true
            }
          )

          Track the returned child_session_id and worktree_id for later use.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: wait_for_worker
        when: "mcp_called('gobby-agents', 'spawn_agent')"
      - to: spawn_failed
        when: "mcp_failed('gobby-agents', 'spawn_agent')"

  - name: spawn_failed
    description: "Handle spawn_agent failure"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Worker spawn failed.

          The spawn_agent call failed. This could be due to:
          - No available worktrees
          - Invalid task ID
          - Terminal/provider configuration issues

          Logging the failure and returning to find_work to try another task.

    allowed_tools:
      - mcp__gobby__call_tool
      - Read

    transitions:
      - to: find_work
        when: "always"

  - name: wait_for_worker
    description: "Wait for task completion"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Waiting for worker to complete.

          Timeout: {{ variables.worker_timeout }} seconds

          Wait for the task to be closed:

          mcp__gobby__call_tool(
            server_name="gobby-tasks",
            tool_name="wait_for_task",
            arguments={
              "task_id": "<task_id_being_worked>",
              "timeout": {{ variables.worker_timeout }}
            }
          )

          The wait returns:
          - completed: true if task reached closed/review status
          - timed_out: true if timeout reached
          - wait_time: how long we waited

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: handle_timeout
        when: "mcp_result_has('gobby-tasks', 'wait_for_task', 'timed_out', true)"
      - to: collect_results
        when: "mcp_called('gobby-tasks', 'wait_for_task')"

  - name: handle_timeout
    description: "Handle worker timeout"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Worker timed out.

          The worker did not complete within {{ variables.worker_timeout }} seconds.

          Options:
          1. Check if the worker is still running
          2. Escalate or reassign the task
          3. Continue to next task

          Poll for any messages from the child before deciding:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="poll_messages",
            arguments={"session_id": "<your_session_id>"}
          )

          Then check the task status and decide whether to retry or move on.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: find_work
        when: "mcp_called('gobby-agents', 'poll_messages')"

  - name: collect_results
    description: "Poll messages, loop back"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Collecting results from worker.

          Poll for messages from the child:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="poll_messages",
            arguments={"session_id": "<your_session_id>"}
          )

          Review any messages from the child agent.
          Then loop back to find_work for the next task.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: merge_worktree
        when: "mcp_called('gobby-agents', 'poll_messages')"
      - to: complete
        when: "task_tree_complete(variables.session_task)"

  - name: merge_worktree
    description: "Merge worktree branch and cleanup"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Merging worktree and cleaning up.

          Approve the completed task and merge its worktree branch:

          mcp__gobby__call_tool(
            server_name="gobby-tasks",
            tool_name="approve_and_cleanup",
            arguments={
              "task_id": "<task_id_just_completed>",
              "push_branch": false,
              "delete_worktree": true
            }
          )

          This will:
          - Merge the worktree branch into the base branch
          - Delete the git worktree
          - Update the task status

          After cleanup, loop back to find_work for the next task.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read
      - Bash

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: find_work
        when: "mcp_called('gobby-tasks', 'approve_and_cleanup')"

  - name: complete
    description: "All tasks done"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: All work complete!

          Session task {{ variables.session_task }} and all subtasks are closed.

          The auto-task-claude workflow will now exit.
          You may stop the session or start a new task.

exit_condition: "task_tree_complete(variables.session_task)"

on_premature_stop:
  action: guide_continuation
  message: "Task orchestration incomplete. Use suggest_next_task() or wait for workers. Do not wait for user confirmation to proceed."
