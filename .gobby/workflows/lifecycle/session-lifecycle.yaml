name: session-lifecycle
description: "Unified session lifecycle: context handoff and memory"
type: lifecycle

settings:
  priority: 10 # Run first - critical for handoff before other LLM calls

# Session-scoped variables (can be overridden per session)
# These provide runtime control over behavior settings
variables:
  # Task enforcement - require active task before file modifications
  require_task_before_edit: true
  # Auto-decompose multi-step task descriptions into subtasks
  auto_decompose: false

  # Task lifecycle policies
  # Block close_task until a commit is linked to the task
  require_commit_before_close: true
  # Block no_commit_needed flag if session has uncommitted (dirty) files
  block_no_commit_with_dirty: true
  # Clear task_claimed variable on successful close_task
  clear_task_on_close: true

triggers:
  on_stop:
    # Task closure enforcement - block stop if task is still in_progress
    # Agents must close_task() or set to review before stopping
    # Skip in plan mode (set via gobby-workflows.set_variable when entering plan mode)
    - action: require_task_review_or_close_before_stop
      when: "not variables.get('plan_mode')"

  on_session_start:
    # Capture baseline dirty files for session-aware commit detection
    # Must run FIRST so baseline is captured before any modifications
    - action: capture_baseline_dirty_files

    # Context handoff - inject previous session summary
    - action: inject_context
      when: "event.data.get('source') == 'clear'"
      source: previous_session_summary
      require: true # Block if handoff context missing
      template: |
        ## Previous Session Context
        *Injected by Gobby session handoff*

        {{ summary }}

    # Context handoff - inject compact handoff after compaction
    - action: inject_context
      when: "event.data.get('source') == 'compact'"
      source: compact_handoff
      require: true # Block if handoff context missing
      template: |
        ## Continuation Context
        *Injected by Gobby compact handoff*

        {{ handoff }}

    # Memory sync - import from JSONL for Git persistence
    - action: memory_sync_import

    # Task sync - import from JSONL for Git persistence
    - action: task_sync_import

    # Plan mode prompt - ONLY on fresh sessions (not handoffs/compacts)
    - action: inject_context
      when: "event.data.get('source') == 'startup'"
      template: |
        ## Session Start: Plan Mode Recommended
        *Injected by Gobby session startup*

        This is a new session. Before executing any code changes, consider:
        1. Understanding the user's full request
        2. Exploring the codebase to gather context
        3. Creating a plan before implementation

        If the user's request involves non-trivial changes, use `/plan` or
        suggest entering plan mode before proceeding with edits.

        Do not assume you know any of the downstream mcp servers proxied by the gobby mcp server, 
        or their tool schemas. Use progressive disclosure to minimize tokens:

        1. `list_tools(server="...")` - Brief metadata only
        2. `get_tool_schema(server_name, tool_name)` - Full schema when needed
        3. `call_tool(server_name, tool_name, arguments)` - Execute

  on_before_agent:
    # Title synthesis on first prompt
    - action: synthesize_title
      when: "session.title == None"

    # Memory recall - inject memories relevant to the user's prompt
    - action: memory_recall_relevant
      limit: 5
      min_importance: 0.7

  on_before_tool:
    # Unified tool blocking with multiple rules
    - action: block_tools
      rules:
        # Block CC native task tools entirely - use gobby-tasks MCP tools instead
        - tools: [TaskCreate, TaskUpdate, TaskGet, TaskList]
          reason: |
            CC native task tools are disabled. Use gobby-tasks MCP tools:
            - create_task(title, description, session_id, claim=True) - Create and auto-claim new task.
            - claim_task(task_id, session_id) - Claim existing unclaimed task.
            - list_ready_tasks() - List available tasks.

        # Block file edits without active task (replaces require_active_task)
        - tools: [Edit, Write, NotebookEdit]
          when: "not task_claimed and not variables.get('plan_mode')"
          reason: |
            Task Required: Claim a task before editing files.
            - create_task(title, description, session_id, claim=True) - Create and auto-claim new task.
            - claim_task(task_id, session_id) - Claim existing unclaimed task.

        # Block close_task with no_commit_needed if session has dirty files
        # This prevents agents from incorrectly using no_commit_needed when they have uncommitted changes
        - mcp_tools: ["gobby-tasks:close_task"]
          when: "variables.get('block_no_commit_with_dirty') and tool_input.get('no_commit_needed') and session_has_dirty_files"
          reason: |
            Cannot use no_commit_needed=True with uncommitted changes.

            You have modified files that haven't been committed. Either:
            1. Commit your changes: git commit -m "[#N] description"
            2. Then close with commit_sha: close_task(task_id="#N", commit_sha="<sha>")

            no_commit_needed is only for tasks with NO code changes (research, planning).

        # Block close_task without a linked commit (unless using special close reasons)
        - mcp_tools: ["gobby-tasks:close_task"]
          when: "variables.get('require_commit_before_close') and not task_has_commits and not tool_input.get('no_commit_needed') and not tool_input.get('commit_sha')"
          reason: |
            A commit is required before closing this task.

            Either:
            1. Pass commit_sha: close_task(task_id="#N", commit_sha="<sha>")
            2. Include [#N] in commit message for auto-linking, then close_task(task_id="#N")
            3. For non-code tasks: close_task(task_id="#N", no_commit_needed=True, override_justification="...")

  on_session_end:
    # Session summary generation - always runs on session end
    # Uses external prompt from prompts collection: handoff/session_end.md
    - action: generate_handoff
      include:
        - artifacts
        - pending_tasks
      prompt: handoff/session_end

    # Extract memories from session (before sync export)
    - action: memory_extract
      min_importance: 0.7
      max_memories: 5

    # Memory sync - export to JSONL for Git persistence
    - action: memory_sync_export

    # Task sync - export to JSONL for Git persistence
    - action: task_sync_export

  on_pre_compact:
    # Extract structured context before compaction
    # Saves formatted markdown to session.compact_markdown
    - action: extract_handoff_context
    
    # Memory sync - export to JSONL for Git persistence
    - action: memory_sync_export

    # Task sync - export to JSONL for Git persistence
    - action: task_sync_export

    # Generate LLM summary with cumulative compression
    # Each compact builds on previous summary, weighting recent work higher
    # Uses external prompt from prompts collection: handoff/compact.md
    - action: generate_handoff
      mode: compact
      prompt: handoff/compact
