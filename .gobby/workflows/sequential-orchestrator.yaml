name: sequential-orchestrator
description: |
  Sequential multi-agent orchestration workflow.

  Manages sequential task execution with the following steps:
  1. select_task: Choose the next ready task from the task tree
  2. spawn_agent: Spawn an agent to work on the selected task
  3. wait: Wait for the spawned agent to complete
  4. review: Review the completed work
  5. decide: Decide whether to continue or complete
  6. loop: Check for more tasks and loop back or complete

  Features:
  - Sequential task processing (one at a time)
  - Agent spawning in worktrees
  - Automatic task selection based on dependencies
  - Review step for quality checks
  - Exit condition based on task tree completion

version: "1.0"
type: step

variables:
  session_task: null          # Epic/parent task ID
  target_branch: "dev"        # Branch to merge into
  worktree_id: null           # Created worktree ID
  worktree_path: null         # Path to worktree
  coding_provider: "gemini"   # Provider for subtasks
  spawn_mode: "terminal"      # Mode for spawning subagents
  current_agent_run_id: null  # Track spawned agent
  current_task_id: null       # Currently selected task
  spawn_retry_count: 0        # Counter for spawn failures
  max_spawn_retries: 3        # Max spawn attempts before failing
  wait_attempts: 0            # Counter for wait polling attempts
  max_wait_attempts: 120      # Max wait attempts (~2 hours at 60s intervals)

steps:
  - name: select_task
    description: "Select the next ready task from the task tree"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Selecting next task.

          Use suggest_next_task(session_id=<your_session_id>) to find the next
          ready subtask of {{ variables.session_task }}.

          If a task is available:
          - Store the task_id in current_task_id variable
          - Transition to 'spawn_agent' step

          If no tasks are ready:
          - Check if all tasks are complete
          - Transition to 'loop' to evaluate

    allowed_tools: all

    transitions:
      - to: spawn_agent
        when: "variables.current_task_id is not None"
      - to: loop
        when: "variables.current_task_id is None"

  - name: spawn_agent
    description: "Spawn an agent to work on the selected task"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Spawning agent for task.

          Task: {{ variables.current_task_id }}
          Provider: {{ variables.coding_provider }}
          Mode: {{ variables.spawn_mode }}
          Worktree: {{ variables.worktree_path }}
          Spawn attempt: {{ variables.spawn_retry_count + 1 }} / {{ variables.max_spawn_retries }}

          Use start_agent() with:
          - provider: {{ variables.coding_provider }}
          - mode: {{ variables.spawn_mode }}
          - project_path: {{ variables.worktree_path }}
          - task: {{ variables.current_task_id }}
          - workflow: "worktree-agent"

          Store the run_id in current_agent_run_id variable.
          If start_agent() fails, increment spawn_retry_count.

    allowed_tools: all

    transitions:
      - to: wait
        when: "variables.current_agent_run_id is not None"
      - to: select_task
        when: "variables.current_agent_run_id is None and variables.spawn_retry_count < variables.max_spawn_retries"
      - to: handle_spawn_error
        when: "variables.current_agent_run_id is None and variables.spawn_retry_count >= variables.max_spawn_retries"

  - name: handle_spawn_error
    description: "Handle repeated spawn failures"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Spawn failed after {{ variables.spawn_retry_count }} attempts.

          Task: {{ variables.current_task_id }}
          Provider: {{ variables.coding_provider }}

          The agent failed to spawn after maximum retries.

          Options:
          1. Check provider availability and configuration
          2. Review task requirements
          3. Skip this task and continue with others
          4. Abort the orchestration

          To skip task: close_task() with reason="spawn_failed" and go to 'loop'
          To retry: reset spawn_retry_count to 0 and go to 'spawn_agent'
          To abort: go to 'complete' with error status

    allowed_tools: all

    transitions:
      - to: loop
        when: "variables.current_task_id is None"
      - to: spawn_agent
        when: "variables.spawn_retry_count == 0 and variables.current_task_id is not None"

  - name: wait
    description: "Wait for the spawned agent to complete"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Waiting for agent.

          Agent run_id: {{ variables.current_agent_run_id }}
          Wait attempt: {{ variables.wait_attempts + 1 }} / {{ variables.max_wait_attempts }}

          Poll with get_agent_result(run_id="{{ variables.current_agent_run_id }}")

          Timeout policy: After {{ variables.max_wait_attempts }} poll attempts
          (~2 hours at 60s intervals), the wait will timeout.

          When agent completes (status: success/error/timeout):
          - Note the result
          - Clear current_agent_run_id
          - Reset wait_attempts to 0
          - Transition to 'review' step

          On each poll iteration, increment wait_attempts.
          If max_wait_attempts exceeded, transition to 'handle_wait_timeout'.

    allowed_tools: all

    transitions:
      - to: review
        when: "variables.current_agent_run_id is None"
      - to: handle_wait_timeout
        when: "variables.wait_attempts >= variables.max_wait_attempts"

  - name: handle_wait_timeout
    description: "Handle agent wait timeout"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Agent wait timed out.

          Agent run_id: {{ variables.current_agent_run_id }}
          Task: {{ variables.current_task_id }}
          Wait attempts: {{ variables.wait_attempts }}

          The agent did not complete within the expected time.

          Options:
          1. Cancel the agent with cancel_agent() and retry
          2. Skip this task and continue
          3. Abort the orchestration

          To proceed:
          - Clear current_agent_run_id
          - Reset wait_attempts to 0
          - Transition to 'review' with timeout status

    allowed_tools: all

    transitions:
      - to: review
        when: "variables.current_agent_run_id is None and variables.wait_attempts == 0"

  - name: review
    description: "Review the completed work"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Reviewing completed work.

          Task: {{ variables.current_task_id }}
          Worktree: {{ variables.worktree_path }}

          Review the changes:
          1. Check git log for recent commits
          2. Verify task requirements were met
          3. Note any issues or follow-ups needed

          When review is complete, transition to 'decide'.

    allowed_tools: all

    transitions:
      - to: decide
        when: "true"

  - name: decide
    description: "Decide whether to continue or complete"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Deciding next action.

          Just completed: {{ variables.current_task_id }}

          Clear the current_task_id and transition to 'loop'
          to check for more tasks.

    allowed_tools: all

    transitions:
      - to: loop
        when: "true"

  - name: loop
    description: "Check for more tasks and loop or complete"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Checking task status.

          Epic: {{ variables.session_task }}

          Check if there are more ready tasks:
          - Use list_ready_tasks() or suggest_next_task()
          - If tasks available: go to 'select_task'
          - If no tasks and tree complete: go to 'complete'

    allowed_tools: all

    transitions:
      - to: select_task
        when: "has_ready_tasks(variables.session_task)"
      - to: complete
        when: "not has_ready_tasks(variables.session_task)"

  - name: complete
    description: "Orchestration complete - all tasks done"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Complete!

          All subtasks of {{ variables.session_task }} have been processed.

          Worktree: {{ variables.worktree_path }}

          The orchestration is complete. You may now:
          - Review the final state
          - Merge the worktree if appropriate
          - Close the epic task

exit_condition: "task_tree_complete(variables.session_task)"

on_premature_stop:
  action: guide_continuation
  message: |
    You cannot stop yet. The epic task tree is not complete.

    Current state:
    - Epic: {{ variables.session_task }}
    - Worktree: {{ variables.worktree_path }}
    - Current task: {{ variables.current_task_id }}
    - Current agent: {{ variables.current_agent_run_id }}

    If an agent is running, wait for it to complete.
    If no agent is running, select the next task.
    Continue until task_tree_complete({{ variables.session_task }}).
