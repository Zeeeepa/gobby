"""
Claude Code transcript parser.

Parses JSONL transcript files generated by Claude Code CLI.
"""

from __future__ import annotations

import logging

logger = logging.getLogger(__name__)


class ClaudeTranscriptParser:
    """
    Parses JSONL transcript files from Claude Code.

    Implements the TranscriptParser protocol for Claude Code's specific
    transcript format. Session boundaries are marked by /clear commands.

    This is a stateless utility class that provides methods for reading,
    parsing, and analyzing transcript files. It does not maintain any
    session state and can be shared across multiple sessions.

    Thread-safe: All methods are stateless and can be called concurrently.
    """

    def __init__(self, logger_instance: logging.Logger | None = None):
        """
        Initialize ClaudeTranscriptParser.

        Args:
            logger_instance: Optional logger instance to use. If not provided,
                           uses the module-level logger.
        """
        self.logger = logger_instance or logger

    def extract_last_messages(self, turns: list[dict], num_pairs: int = 2) -> list[dict]:
        """
        Extract last N user<>agent message pairs from transcript.

        Args:
            turns: List of transcript turns
            num_pairs: Number of user/agent message pairs to extract (default: 2)

        Returns:
            List of message dicts with "role" and "content" fields, ordered chronologically

        Example:
            >>> parser = ClaudeTranscriptParser()
            >>> messages = parser.read_jsonl("/path/to/transcript.jsonl")
            >>> last_msgs = parser.extract_last_messages(messages, num_pairs=3)
            >>> len(last_msgs)
            6  # 3 pairs = 6 messages
        """
        messages: list[dict[str, str]] = []
        for turn in reversed(turns):
            # Claude Code transcript structure has message nested
            message = turn.get("message", {})
            role = message.get("role")
            if role in ["user", "assistant"]:
                content = message.get("content", "")

                # Assistant messages have content as array of blocks
                if isinstance(content, list):
                    text_parts = []
                    for block in content:
                        if isinstance(block, dict) and block.get("type") == "text":
                            text_parts.append(block.get("text", ""))
                    content = " ".join(text_parts)

                messages.insert(0, {"role": role, "content": str(content)})
                if len(messages) >= num_pairs * 2:
                    break
        return messages

    def extract_turns_since_clear(self, turns: list[dict], max_turns: int = 50) -> list[dict]:
        """
        Extract turns since the most recent /clear, up to max_turns.

        Logic:
        1. Find most recent /clear in the transcript (handling consecutive /clears as one boundary)
        2. Start from the turn AFTER the last /clear
        3. Go back up to max_turns but stop if we hit another /clear
        4. Consecutive /clear commands are treated as a single conversation boundary

        Args:
            turns: List of all transcript turns
            max_turns: Maximum number of turns to extract (default: 50)

        Returns:
            List of turns representing the current conversation segment

        Example:
            Turn 100: user message
            Turn 101: /clear
            Turn 102: /clear (consecutive)
            Turn 103: user message
            Turn 104: agent message

            -> Returns turns 103-104 (after the /clear cluster)
        """
        if not turns:
            return []

        # Find the most recent /clear by scanning backwards
        # We want the LAST /clear in any consecutive cluster
        most_recent_clear_idx = None
        for i in range(len(turns) - 1, -1, -1):
            if self.is_session_boundary(turns[i]):
                # Found a /clear - this is the most recent one
                most_recent_clear_idx = i
                break

        # If no /clear found, just take the last max_turns
        if most_recent_clear_idx is None:
            return turns[-max_turns:] if len(turns) > max_turns else turns

        # Start after this /clear (which is the last in any cluster since we scanned backwards)
        start_idx = most_recent_clear_idx + 1
        end_idx = len(turns)

        # Now go backwards from the /clear we found to check for:
        # 1. Another /clear (conversation boundary)
        # 2. Max turns limit
        # We want at most max_turns AFTER the most recent /clear
        # So if we have 150 total turns and most_recent_clear is at 100,
        # we want to limit to turns 101-150 (50 turns) if end is at 150

        # If the segment after most_recent_clear is already <= max_turns, we're done
        segment_size = end_idx - start_idx
        if segment_size <= max_turns:
            # Check if there's a previous /clear we should respect
            search_idx = most_recent_clear_idx - 1

            # Skip consecutive /clears going backwards
            while search_idx >= 0 and self.is_session_boundary(turns[search_idx]):
                search_idx -= 1

            # Search for previous /clear boundary (no max_turns limit since current segment is small)
            for i in range(search_idx, -1, -1):
                if self.is_session_boundary(turns[i]):
                    # Found previous /clear - make sure we start after it
                    boundary_idx = i
                    # Skip forward over consecutive /clears
                    while boundary_idx < most_recent_clear_idx and self.is_session_boundary(
                        turns[boundary_idx + 1]
                    ):
                        boundary_idx += 1
                    start_idx = max(start_idx, boundary_idx + 1)
                    break

            return turns[start_idx:end_idx]

        # Segment is > max_turns, so we need to limit it
        # Take the last max_turns from the segment
        start_idx = end_idx - max_turns

        # But make sure we don't cross a /clear boundary
        search_idx = most_recent_clear_idx - 1

        # Skip consecutive /clears going backwards
        while search_idx >= 0 and self.is_session_boundary(turns[search_idx]):
            search_idx -= 1

        # Check if there's a /clear between start_idx and most_recent_clear_idx
        for i in range(most_recent_clear_idx - 1, start_idx - 1, -1):
            if self.is_session_boundary(turns[i]):
                # Found a /clear in our window - start after it
                boundary_idx = i
                while boundary_idx < most_recent_clear_idx and self.is_session_boundary(
                    turns[boundary_idx + 1]
                ):
                    boundary_idx += 1
                start_idx = boundary_idx + 1
                break

        return turns[start_idx:end_idx]

    def is_session_boundary(self, turn: dict) -> bool:
        """
        Check if a turn is a session boundary (/clear command).

        Args:
            turn: Transcript turn dict

        Returns:
            True if turn contains a /clear command marker

        Example:
            >>> parser = ClaudeTranscriptParser()
            >>> turn = {"type": "user", "message": {"content": "<command-name>/clear</command-name>"}}
            >>> parser.is_session_boundary(turn)
            True
        """
        if turn.get("type") != "user":
            return False

        message = turn.get("message", {})
        content = message.get("content", "")

        # Check for /clear command marker
        return "<command-name>/clear</command-name>" in str(content)

    # Backward-compatible alias
    is_clear_command = is_session_boundary


# Backward-compatible alias for existing code
TranscriptProcessor = ClaudeTranscriptParser
