"""
Codex transcript parser.

Parses JSONL transcript files generated by Codex CLI.
"""

from __future__ import annotations

import json
import logging
from datetime import UTC, datetime
from typing import Any

from gobby.sessions.transcripts.base import ParsedMessage

logger = logging.getLogger(__name__)


class CodexTranscriptParser:
    """
    Parses JSONL transcript files from Codex.

    Implements the TranscriptParser protocol for Codex's transcript format.
    """

    def __init__(self, logger_instance: logging.Logger | None = None):
        self.logger = logger_instance or logger

    def extract_last_messages(
        self, turns: list[dict[str, Any]], num_pairs: int = 2
    ) -> list[dict[str, Any]]:
        messages: list[dict[str, str]] = []
        for turn in reversed(turns):
            role = turn.get("role")
            content = turn.get("content")

            if role in ["user", "assistant", "system"]:
                messages.insert(0, {"role": role, "content": str(content)})
                if len(messages) >= num_pairs * 2:
                    break
        return messages

    def extract_turns_since_clear(
        self, turns: list[dict[str, Any]], max_turns: int = 50
    ) -> list[dict[str, Any]]:
        # Codex likely uses a new session or clear command
        # For now, default to tail
        return turns[-max_turns:] if len(turns) > max_turns else turns

    def is_session_boundary(self, turn: dict[str, Any]) -> bool:
        return False

    def parse_line(self, line: str, index: int) -> ParsedMessage | None:
        if not line.strip():
            return None

        try:
            data = json.loads(line)
        except json.JSONDecodeError:
            self.logger.warning(f"Invalid JSON at line {index}")
            return None

        timestamp = datetime.now(UTC)
        if "timestamp" in data:
            try:
                timestamp = datetime.fromisoformat(data["timestamp"].replace("Z", "+00:00"))
            except ValueError:
                pass

        # Assume simple schema for Codex: {"role": "user", "content": "..."}
        role = data.get("role")
        content = data.get("content", "")

        if not role:
            return None

        content_type = "text"
        tool_name = None

        # Check for tool use if Codex supports it in this format
        if role == "tool" or "tool_calls" in data:
            pass  # Placeholder for tool logic

        return ParsedMessage(
            index=index,
            role=role,
            content=str(content),
            content_type=content_type,
            tool_name=tool_name,
            tool_input=None,
            tool_result=None,
            timestamp=timestamp,
            raw_json=data,
        )

    def parse_lines(self, lines: list[str], start_index: int = 0) -> list[ParsedMessage]:
        parsed_messages = []
        current_index = start_index

        for line in lines:
            message = self.parse_line(line, current_index)
            if message:
                parsed_messages.append(message)
                current_index += 1

        return parsed_messages
