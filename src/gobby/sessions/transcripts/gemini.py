"""
Gemini transcript parser.

Parses JSONL transcript files generated by Gemini CLI.
"""

from __future__ import annotations

import json
import logging
from datetime import UTC, datetime
from typing import Any

from gobby.sessions.transcripts.base import ParsedMessage

logger = logging.getLogger(__name__)


class GeminiTranscriptParser:
    """
    Parses JSONL transcript files from Gemini.

    Implements the TranscriptParser protocol for Gemini's transcript format.
    Assumes a standard JSONL structure where each line is a message or event.
    """

    def __init__(self, logger_instance: logging.Logger | None = None):
        """
        Initialize GeminiTranscriptParser.

        Args:
            logger_instance: Optional logger instance.
        """
        self.logger = logger_instance or logger

    def extract_last_messages(
        self, turns: list[dict[str, Any]], num_pairs: int = 2
    ) -> list[dict[str, Any]]:
        """
        Extract last N user<>agent message pairs.
        """
        messages: list[dict[str, str]] = []
        for turn in reversed(turns):
            # Adapt to generic turn structure
            # Assumes generic schema: {"role": "...", "content": "..."} or nested in "message"
            role = turn.get("role") or turn.get("message", {}).get("role")
            content = turn.get("content") or turn.get("message", {}).get("content")

            if role in ["user", "model", "assistant"]:
                norm_role = "assistant" if role == "model" else role

                # Handle complex content types if necessary
                if isinstance(content, list):
                    content = " ".join(str(part) for part in content)

                messages.insert(0, {"role": norm_role, "content": str(content)})
                if len(messages) >= num_pairs * 2:
                    break
        return messages

    def extract_turns_since_clear(
        self, turns: list[dict[str, Any]], max_turns: int = 50
    ) -> list[dict[str, Any]]:
        """
        Extract turns since the most recent session boundary.
        For Gemini, we might look for specific clear events or just return the tail.
        """
        # Placeholder: just return last N turns for now until we know the clear signal
        return turns[-max_turns:] if len(turns) > max_turns else turns

    def is_session_boundary(self, turn: dict[str, Any]) -> bool:
        """
        Check if a turn is a session boundary.
        """
        # Placeholder for Gemini specific boundary
        return False

    def parse_line(self, line: str, index: int) -> ParsedMessage | None:
        """
        Parse a single line from the transcript JSONL.
        """
        if not line.strip():
            return None

        try:
            data = json.loads(line)
        except json.JSONDecodeError:
            self.logger.warning(f"Invalid JSON at line {index}")
            return None

        # Extract timestamp
        timestamp_str = data.get("timestamp") or datetime.now(UTC).isoformat()
        try:
            timestamp = datetime.fromisoformat(timestamp_str.replace("Z", "+00:00"))
        except ValueError:
            timestamp = datetime.now(UTC)

        # Determine role and content
        # Check top-level or nested 'message'
        role = data.get("role")
        content = data.get("content")

        if not role and "message" in data:
            msg = data["message"]
            role = msg.get("role")
            content = msg.get("content")

        if not role:
            # Try type field common in other schemas
            msg_type = data.get("type")
            if msg_type == "user":
                role = "user"
            elif msg_type == "model":
                role = "assistant"

        # Normalize role
        if role == "model":
            role = "assistant"

        if not role:
            # Maybe a tool result or system event
            if "tool_result" in data:
                role = "tool"
                content = str(data["tool_result"])
            else:
                # Unknown or uninteresting line
                return None

        # Normalize content
        content_type = "text"
        tool_name = None
        tool_input = None
        tool_result = None

        if isinstance(content, list):
            # Handle potential rich content
            text_parts: list[str] = []
            for part in content:
                if isinstance(part, str):
                    text_parts.append(part)
                elif isinstance(part, dict):
                    if "text" in part:
                        text_parts.append(str(part["text"]))
                    # Check for tool calls
                    if "functionCall" in part:
                        content_type = "tool_use"
                        tool_name = part["functionCall"].get("name")
                        tool_input = part["functionCall"].get("args")
            content = " ".join(text_parts)
        else:
            content = str(content or "")

        return ParsedMessage(
            index=index,
            role=role,
            content=content,
            content_type=content_type,
            tool_name=tool_name,
            tool_input=tool_input,
            tool_result=tool_result,
            timestamp=timestamp,
            raw_json=data,
        )

    def parse_lines(self, lines: list[str], start_index: int = 0) -> list[ParsedMessage]:
        """
        Parse a list of transcript lines.
        """
        parsed_messages = []
        current_index = start_index

        for line in lines:
            message = self.parse_line(line, current_index)
            if message:
                parsed_messages.append(message)
                current_index += 1

        return parsed_messages
