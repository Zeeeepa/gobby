name: session-lifecycle
description: "Unified session lifecycle: context handoff and memory"
type: lifecycle

settings:
  priority: 10 # Run first - critical for handoff before other LLM calls

# Session-scoped variables (can be overridden per session)
# These provide runtime control over behavior settings
variables:
  # Task enforcement - require active task before file modifications
  require_task_before_edit: true

  # Task lifecycle policies
  # Block close_task until a commit is linked to the task
  require_commit_before_close: true
  # Clear task_claimed variable on successful close_task
  clear_task_on_close: true

  # Progressive tool discovery - require get_tool_schema before call_tool
  # Set to false to disable this enforcement
  enforce_tool_schema_check: true
  # List of server:tool combos that have been unlocked via get_tool_schema
  # Reset on compact/clear since context is lost
  unlocked_tools: []

triggers:
  on_stop:
    # Task closure enforcement - block stop if task is still in_progress
    # Agents must close_task() or set to review before stopping
    # Skip in plan mode (set via gobby-workflows.set_variable when entering plan mode)
    - action: require_task_review_or_close_before_stop
      when: "not variables.get('plan_mode')"

  on_session_start:
    # Clear plan_mode on new sessions - don't inherit from parent session
    # This prevents implementation sessions from inheriting plan_mode=True
    # from planning sessions that created the plan
    - action: set_variable
      when: "event.data.get('source') in ['clear', 'compact', 'startup']"
      name: plan_mode
      value: false

    # Reset unlocked_tools on compact/clear since context is lost
    # Agent must re-learn schemas after context compaction
    - action: set_variable
      when: "event.data.get('source') in ['clear', 'compact']"
      name: unlocked_tools
      value: []

    # Capture baseline dirty files for session-aware commit detection
    # Must run FIRST so baseline is captured before any modifications
    - action: capture_baseline_dirty_files

    # Context handoff - inject previous session summary
    - action: inject_context
      when: "event.data.get('source') == 'clear'"
      source: previous_session_summary
      require: true # Block if handoff context missing
      template: |
        ## Previous Session Context
        *Injected by Gobby session handoff*

        {{ summary }}

    # Context handoff - inject compact handoff after compaction
    - action: inject_context
      when: "event.data.get('source') == 'compact'"
      source: compact_handoff
      require: true # Block if handoff context missing
      template: |
        ## Continuation Context
        *Injected by Gobby compact handoff*

        {{ handoff }}

    # Memory sync - import from JSONL for Git persistence
    - action: memory_sync_import

    # Task sync - import from JSONL for Git persistence
    - action: task_sync_import

    # Plan mode prompt - ONLY on fresh sessions (not handoffs/compacts)
    - action: inject_context
      when: "event.data.get('source') == 'startup'"
      template: |
        ## Session Start: Plan Mode Recommended
        *Injected by Gobby session startup*

        This is a new session. Before executing any code changes, consider:
        1. Understanding the user's full request
        2. Exploring the codebase to gather context
        3. Creating a plan before implementation

        If the user's request involves non-trivial changes, use `/plan` or
        suggest entering plan mode before proceeding with edits.

        Do not assume you know any of the downstream mcp servers proxied by the gobby mcp server, 
        or their tool schemas. Use progressive disclosure to minimize tokens:

        1. `list_tools(server="...")` - Brief metadata only
        2. `get_tool_schema(server_name, tool_name)` - Full schema when needed
        3. `call_tool(server_name, tool_name, arguments)` - Execute

  on_before_agent:
    # Title synthesis on first prompt
    - action: synthesize_title
      when: "session.title == None"

    # Memory recall - inject memories relevant to the user's prompt
    - action: memory_recall_relevant
      limit: 5
      min_importance: 0.7

  on_before_tool:
    # Unified tool blocking with multiple rules
    - action: block_tools
      rules:
        # Block CC native task tools entirely - use gobby-tasks MCP tools instead
        - tools: [TaskCreate, TaskUpdate, TaskGet, TaskList]
          reason: |

            CC native task tools are disabled. Use gobby-tasks MCP tools instead:
            - create_task(title, description, session_id, claim=True) - Create and auto-claim new task.
            - claim_task(task_id, session_id) - Claim existing unclaimed task.
            - list_ready_tasks() - List available tasks.

        # Block file edits without active task (replaces require_active_task)
        # Allow plan file writes during plan mode (/.claude/plans/ path check)
        - tools: [Edit, Write, NotebookEdit]
          when: "not task_claimed and not plan_mode and not is_plan_file(tool_input.get('file_path', ''), source)"
          reason: |

            Task Required: Claim a task before editing files.
            - create_task(title, description, session_id, claim=True) - Create and auto-claim new task.
            - claim_task(task_id, session_id) - Claim existing unclaimed task.

        # Block close_task without a linked commit (unless using special close reasons)
        - mcp_tools: ["gobby-tasks:close_task"]
          when: "variables.get('require_commit_before_close') and not task_has_commits and not tool_input.get('commit_sha') and tool_input.get('reason') not in ['already_implemented', 'obsolete', 'duplicate', 'wont_fix']"
          reason: |

            A commit is required before closing this task.

            **Normal flow:**
            1. Commit your changes: git commit -m "[#N] description"
            2. Close with commit_sha: close_task(task_id="#N", commit_sha="<sha>")

            **Edge cases (no work done):**
            - Task was already done: reason="already_implemented"
            - Task is no longer needed: reason="obsolete"
            - Task duplicates another: reason="duplicate"
            - Decided not to do it: reason="wont_fix"

        # Block call_tool if schema wasn't fetched first (progressive disclosure)
        # Skip for discovery tools (list_tools, get_tool_schema, etc.)
        # Uses 'tools' (not mcp_tools) since we're intercepting the actual tool name
        - tools: ["mcp__gobby__call_tool"]
          when: "variables.get('enforce_tool_schema_check') and not is_discovery_tool(tool_input.get('tool_name')) and not is_tool_unlocked(tool_input)"
          reason: |

            Schema required before calling call_tool("{{ tool_input.get('server_name') }}", "{{ tool_input.get('tool_name') }}").

            Run first:
              get_tool_schema("{{ tool_input.get('server_name') }}", "{{ tool_input.get('tool_name') }}")

  on_after_tool:
    # Track successful get_tool_schema calls to unlock tools for call_tool
    - action: track_schema_lookup

  on_session_end:
    # Session summary generation - always runs on session end
    # Uses external prompt from prompts collection: handoff/session_end.md
    - action: generate_handoff
      include:
        - artifacts
        - pending_tasks
      prompt: handoff/session_end

    # Extract memories from session (before sync export)
    - action: memory_extract
      min_importance: 0.7
      max_memories: 5

    # Memory sync - export to JSONL for Git persistence
    - action: memory_sync_export

    # Task sync - export to JSONL for Git persistence
    - action: task_sync_export

  on_pre_compact:
    # Extract structured context before compaction
    # Saves formatted markdown to session.compact_markdown
    - action: extract_handoff_context
    
    # Memory sync - export to JSONL for Git persistence
    - action: memory_sync_export

    # Task sync - export to JSONL for Git persistence
    - action: task_sync_export

    # Generate LLM summary with cumulative compression
    # Each compact builds on previous summary, weighting recent work higher
    # Uses external prompt from prompts collection: handoff/compact.md
    - action: generate_handoff
      mode: compact
      prompt: handoff/compact
