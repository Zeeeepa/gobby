name: session-lifecycle
description: "Unified session lifecycle: context handoff and memory"
type: lifecycle

settings:
  priority: 10 # Run first - critical for handoff before other LLM calls

# Session-scoped variables (can be overridden per session)
# These provide runtime control over behavior settings
variables:
  # Debug: echo additionalContext to system_message for terminal visibility
  debug_echo_context: true

  # Task enforcement - require active task before file modifications
  require_task_before_edit: true

  # Task lifecycle policies
  # Block close_task until a commit is linked to the task
  require_commit_before_close: true
  # Clear task_claimed variable on successful close_task
  clear_task_on_close: true

  # Progressive tool discovery - require get_tool_schema before call_tool
  # Set to false to disable this enforcement
  enforce_tool_schema_check: true
  # List of server:tool combos that have been unlocked via get_tool_schema
  # Reset on compact/clear since context is lost
  unlocked_tools: []

triggers:
  on_stop:
    # Task closure enforcement - block stop if task is still in_progress
    # Agents must close_task() or set to review before stopping
    # Skip in plan mode (set via gobby-workflows.set_variable when entering plan mode)
    - action: require_task_review_or_close_before_stop
      when: "not variables.get('plan_mode')"

  on_session_start:
    # Clear plan_mode on new sessions - don't inherit from parent session
    # This prevents implementation sessions from inheriting plan_mode=True
    # from planning sessions that created the plan
    - action: set_variable
      when: "event.data.get('source') in ['clear', 'compact', 'startup']"
      name: plan_mode
      value: false

    # Reset unlocked_tools on compact/clear/resume since context is lost
    # Agent must re-learn schemas after context compaction
    # - Claude: 'clear', 'compact'
    # - Gemini: 'clear', 'resume' (after compress)
    - action: set_variable
      when: "event.data.get('source') in ['clear', 'compact', 'resume']"
      name: unlocked_tools
      value: []

    # Reset memory injection tracking on compact/clear/resume since context is lost
    # Allows previously injected memories to be re-injected after context loss
    # - Claude: 'clear' (after /clear), 'compact' (after auto/manual compact)
    # - Gemini: 'clear' (after /clear), 'resume' (after /compress or auto-compress)
    - action: reset_memory_injection_tracking
      when: "event.data.get('source') in ['clear', 'compact', 'resume']"

    # Capture baseline dirty files for session-aware commit detection
    # Must run FIRST so baseline is captured before any modifications
    - action: capture_baseline_dirty_files

    # Context handoff - inject previous session summary
    - action: inject_context
      when: "event.data.get('source') == 'clear'"
      source: previous_session_summary
      require: true # Block if handoff context missing
      template: |
        ## Previous Session Context
        *Injected by Gobby session handoff*

        {{ summary }}

    # Context handoff - inject compact handoff after compaction
    - action: inject_context
      when: "event.data.get('source') == 'compact'"
      source: compact_handoff
      require: true # Block if handoff context missing
      template: |
        ## Continuation Context
        *Injected by Gobby compact handoff*

        {{ handoff }}

    # Memory sync - import from JSONL for Git persistence
    - action: memory_sync_import

    # Task sync - import from JSONL for Git persistence
    - action: task_sync_import

    # Skill and task context injection - inject always-apply skills for all session starts
    # Uses array syntax to combine multiple sources
    - action: inject_context
      source: skills
      filter: always_apply
      template: |
        The following skills are available for use with the Skill tool:

        {{ skills_list }}

    # Inject active task context if session has a claimed task
    - action: inject_context
      source: task_context
      template: |
        {{ task_context }}

    # Plan mode prompt - ONLY on fresh sessions (not handoffs/compacts)
    - action: inject_context
      when: "event.data.get('source') == 'startup'"
      template: |
        ## Session Start: Plan Mode Recommended
        *Injected by Gobby session startup*

        This is a new session. Before executing any code changes, consider:
        1. Understanding the user's full request
        2. Exploring the codebase to gather context
        3. Creating a plan before implementation

        If the user's request involves non-trivial changes, use `/plan` or
        suggest entering plan mode before proceeding with edits.

  on_before_agent:
    # Title synthesis on first prompt
    - action: synthesize_title
      when: "session.title == None"

    # Memory recall - inject memories relevant to the user's prompt
    - action: memory_recall_relevant
      limit: 5
      min_importance: 0.7

  on_before_tool:
    # Unified tool blocking with multiple rules
    - action: block_tools
      rules:
        # Block CC native task tools entirely - use gobby-tasks MCP tools instead
        - tools: [TaskCreate, TaskUpdate, TaskGet, TaskList]
          reason: |

            CC native task tools are disabled. Use gobby-tasks MCP tools instead:
            - create_task(title, description, session_id, claim=True) - Create and auto-claim new task.
            - claim_task(task_id, session_id) - Claim existing unclaimed task.
            - list_ready_tasks() - List available tasks.

        # Block file edits without active task (replaces require_active_task)
        # Allow plan file writes during plan mode (/.claude/plans/ path check)
        - tools: [Edit, Write, NotebookEdit]
          when: "not task_claimed and not plan_mode and not is_plan_file(tool_input.get('file_path', ''), source)"
          reason: |

            Task Required: Claim a task before editing files.
            - create_task(title, description, session_id, claim=True) - Create and auto-claim new task.
            - claim_task(task_id, session_id) - Claim existing unclaimed task.

        # Block call_tool if schema wasn't fetched first (progressive disclosure)
        # Skip for discovery tools (list_tools, get_tool_schema, etc.)
        # Uses 'tools' (not mcp_tools) since we're intercepting the actual tool name
        # NOTE: This rule MUST come before mcp_tools rules so schema check fires first
        - tools: ["mcp__gobby__call_tool"]
          when: "variables.get('enforce_tool_schema_check') and not is_discovery_tool(tool_input.get('tool_name')) and not is_tool_unlocked(tool_input)"
          reason: |

            Schema required before calling call_tool("{{ tool_input.get('server_name') }}", "{{ tool_input.get('tool_name') }}").

            Run first:
              get_tool_schema("{{ tool_input.get('server_name') }}", "{{ tool_input.get('tool_name') }}")

        # Block close_task without a linked commit (unless using special close reasons)
        - mcp_tools: ["gobby-tasks:close_task"]
          when: "variables.get('require_commit_before_close') and not task_has_commits and not tool_input.get('commit_sha') and tool_input.get('reason') not in ['already_implemented', 'obsolete', 'duplicate', 'wont_fix', 'out_of_repo']"
          reason: |

            A commit is required before closing this task.

            **Normal flow:**
            1. Commit your changes: git commit -m "[#N] description"
            2. Close with commit_sha: close_task(task_id="#N", commit_sha="<sha>")

            **Edge cases (no work done):**
            - Task was already done: reason="already_implemented"
            - Task is no longer needed: reason="obsolete"
            - Task duplicates another: reason="duplicate"
            - Decided not to do it: reason="wont_fix"
            - Changes outside repo (e.g., ~/.gobby/config.yaml): reason="out_of_repo"

  on_after_tool:
    # Track successful get_tool_schema calls to unlock tools for call_tool
    - action: track_schema_lookup

  on_session_end:
    # Session summary generation - always runs on session end
    # Uses external prompt from prompts collection: handoff/session_end.md
    - action: generate_handoff
      include:
        - artifacts
        - pending_tasks
      prompt: handoff/session_end

    # Memory capture is now agent-driven via proactive-memory skill
    # Agents save memories during work when they discover valuable insights
    # The memory_extract action remains available for manual/workflow use

    # Memory sync - export to JSONL for Git persistence
    - action: memory_sync_export

    # Task sync - export to JSONL for Git persistence
    - action: task_sync_export

  on_pre_compact:
    # Run compact handoff for:
    # - Claude/other sources: always (single compact event)
    # - Gemini: only on manual /compress (skip auto triggers which fire constantly)
    #
    # Condition: "not gemini" OR "gemini with manual trigger"
    # Equivalent: skip only for "gemini with auto trigger"

    # Extract structured context before compaction
    # Saves formatted markdown to session.compact_markdown
    - action: extract_handoff_context
      when: "event.source.value != 'gemini' or event.data.get('trigger') == 'manual'"

    # Memory sync - export to JSONL for Git persistence
    - action: memory_sync_export
      when: "event.source.value != 'gemini' or event.data.get('trigger') == 'manual'"

    # Task sync - export to JSONL for Git persistence
    - action: task_sync_export
      when: "event.source.value != 'gemini' or event.data.get('trigger') == 'manual'"

    # Generate LLM summary with cumulative compression
    # Each compact builds on previous summary, weighting recent work higher
    # Uses external prompt from prompts collection: handoff/compact.md
    - action: generate_handoff
      when: "event.source.value != 'gemini' or event.data.get('trigger') == 'manual'"
      mode: compact
      prompt: handoff/compact
