name: meeseeks-box
description: |
  Interactive orchestrator for Claude Code terminal.

  This step workflow runs in Claude Code and:
  1. Finds ready tasks using suggest_next_task()
  2. Spawns workers in isolated environments (clone, worktree, or current)
  3. Waits for task completion using wait_for_task()
  4. Reviews code changes (with approval gate)
  5. Merges approved branches via mode-appropriate tools, cleans up
  6. Loops until all session_tasks are complete

  Isolation modes:
  - clone:    Worker runs in a full git clone (default). Merge via gobby-clones.
  - worktree: Worker runs in a git worktree. Merge via git squash-merge + push.
  - current:  Worker runs in the current working tree. No merge/cleanup needed.

  Deterministic steps (find_work, spawn_worker, cleanup) auto-execute
  their MCP calls server-side via call_mcp_tool in on_enter. The LLM only drives
  steps that require judgment or long-running waits.

  Usage:
    1. Create/claim a parent task via gobby-tasks
    2. Activate this workflow with session_task set to the task ID(s)
    3. Optionally set isolation_mode variable ("clone", "worktree", or "current")
    4. Workflow spawns workers per isolation mode for each ready subtask
    5. Reviews changes, merges approved work, loops
    6. Exits when task tree is complete

version: "1.0"
type: step

variables:
  agent_name: null                # Set by spawn_agent (e.g., "meeseeks-gemini", "meeseeks-claude")
  session_task: null              # Root task ID(s) to complete
  isolation_mode: "clone"         # "clone", "worktree", or "current"
  current_worker_id: null         # Active worker run_id
  current_clone_id: null          # Active clone (when isolation_mode=clone)
  current_worktree_id: null       # Active worktree (when isolation_mode=worktree)
  current_branch: null            # Active branch name
  current_task_id: null           # Task being worked
  worker_provider: "gemini"
  worker_terminal: "tmux"
  worker_timeout: 600
  max_inactive_waits: 3
  max_review_attempts: 3
  review_attempt: 0
  review_approved: false
  review_deficiencies: []
  merge_target_branch: "dev"

steps:
  - name: find_work
    description: "Find next ready task using suggest_next_task()"
    on_enter:
      # Clear stale results from previous iteration
      - action: set_variable
        name: _suggest_result
        value: null
      - action: set_variable
        name: current_task_id
        value: null
      # Auto-execute suggest_next_task
      - action: call_mcp_tool
        server_name: gobby-tasks
        tool_name: suggest_next_task
        arguments:
          session_id: "{{ session_id }}"
        output_as: _suggest_result
      # Capture any error from suggest_next_task
      - action: set_variable
        name: _suggest_error
        value: "{{ variables._suggest_result.error if variables._suggest_result and variables._suggest_result.error is defined else '' }}"
      # Extract task_id from result
      - action: set_variable
        name: current_task_id
        value: "{{ variables._suggest_result.suggestion.ref if variables._suggest_result and variables._suggest_result.suggestion is defined and variables._suggest_result.suggestion.ref is defined else '' }}"

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read
      - Glob
      - Grep

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: wait_for_workers
        when: "variables.get('_suggest_error') or not variables.get('current_task_id')"
      - to: spawn_worker
        when: "variables.get('current_task_id')"

  - name: wait_for_workers
    description: "No ready tasks - wait for in-progress workers"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: No ready tasks found.
          {% if variables._suggest_error %}
          suggest_next_task error: {{ variables._suggest_error }}
          {% endif %}
          All tasks are either in progress or blocked. Waiting for workers to complete.

          Poll for messages from child agents:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="poll_messages",
            arguments={"session_id": "<your_session_id>"}
          )

          Then check for newly available tasks.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: find_work
        when: "mcp_called('gobby-agents', 'poll_messages')"

  - name: spawn_worker
    description: "Spawn worker in isolated environment"
    on_enter:
      # Clear stale result
      - action: set_variable
        name: _spawn_result
        value: null
      - action: set_variable
        name: current_worker_id
        value: null
      # Auto-execute spawn_agent
      - action: call_mcp_tool
        server_name: gobby-agents
        tool_name: spawn_agent
        arguments:
          prompt: "You are a worker in an isolated environment.\n\nFIRST, activate your workflow by calling:\n\nmcp__gobby__call_tool(\n  server_name=\"gobby-workflows\",\n  tool_name=\"activate_workflow\",\n  arguments={\n    \"name\": \"{{ variables.agent_name }}:worker\",\n    \"session_id\": \"<your_gobby_session_id>\",\n    \"variables\": {\"assigned_task_id\": \"{{ variables.current_task_id }}\"}\n  }\n)\n\nReplace <your_gobby_session_id> with your Gobby Session ID (shown at startup).\n\nThe workflow will guide you through: claim -> implement -> commit -> close -> report -> shutdown.\n\nDo NOT proceed without activating the workflow first."
          agent: "{{ variables.agent_name }}"
          workflow: "worker"
          task_id: "{{ variables.current_task_id }}"
          isolation: "{{ variables.isolation_mode }}"
          provider: "{{ variables.worker_provider }}"
          terminal: "{{ variables.worker_terminal }}"
          parent_session_id: "{{ session_id }}"
        output_as: _spawn_result
      # Extract worker info from result
      - action: set_variable
        name: current_worker_id
        value: "{{ variables._spawn_result.run_id if variables._spawn_result and variables._spawn_result.run_id is defined else '' }}"
      - action: set_variable
        name: current_clone_id
        value: "{{ variables._spawn_result.clone_id if variables._spawn_result and variables._spawn_result.clone_id is defined else '' }}"
      - action: set_variable
        name: current_worktree_id
        value: "{{ variables._spawn_result.worktree_id if variables._spawn_result and variables._spawn_result.worktree_id is defined else '' }}"
      - action: set_variable
        name: current_branch
        value: "{{ variables._spawn_result.branch_name if variables._spawn_result and variables._spawn_result.branch_name is defined else '' }}"

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: wait_for_worker
        when: "variables.get('current_worker_id')"
      - to: find_work
        when: "not variables.get('current_worker_id')"

  - name: wait_for_worker
    description: "Wait for task completion"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Waiting for worker to complete.

          Task: {{ variables.current_task_id }}
          Worker: {{ variables.current_worker_id }}
          Timeout: {{ variables.worker_timeout }} seconds

          Wait for the task to be closed:

          mcp__gobby__call_tool(
            server_name="gobby-tasks",
            tool_name="wait_for_task",
            arguments={
              "task_id": "{{ variables.current_task_id }}",
              "timeout": {{ variables.worker_timeout }}
            }
          )

          The wait returns:
          - completed: true if task reached closed/review status
          - timed_out: true if timeout reached
          - wait_time: how long we waited

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: handle_timeout
        when: "mcp_result_has('gobby-tasks', 'wait_for_task', 'timed_out', true)"
      - to: code_review
        when: "mcp_called('gobby-tasks', 'wait_for_task')"

  - name: handle_timeout
    description: "Handle worker timeout"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Worker timed out.

          The worker did not complete within the timeout period.

          Poll for any messages from the child:

          mcp__gobby__call_tool(
            server_name="gobby-agents",
            tool_name="poll_messages",
            arguments={"session_id": "<your_session_id>"}
          )

          Check task status and decide whether to retry or escalate.

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: find_work
        when: "mcp_called('gobby-agents', 'poll_messages')"

  - name: code_review
    description: "Review worker's code changes"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Code review phase.

          Task: {{ variables.current_task_id }}
          Branch: {{ variables.current_branch }}
          Isolation: {{ variables.isolation_mode }}
          {% if variables.isolation_mode == 'clone' %}Clone: {{ variables.current_clone_id }}{% endif %}
          {% if variables.isolation_mode == 'worktree' %}Worktree: {{ variables.current_worktree_id }}{% endif %}
          Review attempt: {{ variables.review_attempt + 1 }} / {{ variables.max_review_attempts }}

          Review the worker's changes:

          1. Check the diff:
             git diff main...{{ variables.current_branch }}

          2. Review code quality, tests, security

          3. If approved, set review_approved to true and proceed to merge
          4. If deficiencies found, list them and respawn worker for fixes

          Use the workflow tools to set variables:
          - For approval: set_workflow_variable("review_approved", true)
          - For deficiencies: set_workflow_variable("review_deficiencies", ["list", "of", "issues"])

    allowed_tools:
      - Bash
      - Read
      - Glob
      - Grep
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - spawn_agent

    transitions:
      # Approved — route to appropriate merge step by isolation mode
      - to: merge_clone
        when: "variables.get('review_approved', False) and variables.get('isolation_mode') == 'clone'"
      - to: merge_worktree
        when: "variables.get('review_approved', False) and variables.get('isolation_mode') == 'worktree'"
      - to: push_changes
        when: "variables.get('review_approved', False) and variables.get('isolation_mode') == 'current'"
      # Deficiencies — can retry
      - to: respawn_for_fixes
        when: "len(variables.get('review_deficiencies', [])) > 0 and variables.get('review_attempt', 0) < variables.get('max_review_attempts', 3)"
      # Max retries exceeded — cleanup per isolation mode
      - to: cleanup_clone
        when: "len(variables.get('review_deficiencies', [])) > 0 and variables.get('review_attempt', 0) >= variables.get('max_review_attempts', 3) and variables.get('isolation_mode') == 'clone'"
      - to: cleanup_worktree
        when: "len(variables.get('review_deficiencies', [])) > 0 and variables.get('review_attempt', 0) >= variables.get('max_review_attempts', 3) and variables.get('isolation_mode') == 'worktree'"
      - to: reset_state
        when: "len(variables.get('review_deficiencies', [])) > 0 and variables.get('review_attempt', 0) >= variables.get('max_review_attempts', 3) and variables.get('isolation_mode') == 'current'"

  - name: respawn_for_fixes
    description: "Respawn worker to fix deficiencies"
    on_enter:
      - action: set_variable
        name: review_attempt
        value: "{{ variables.review_attempt + 1 }}"
      - action: set_variable
        name: review_approved
        value: false
      # Clear stale result
      - action: set_variable
        name: _respawn_result
        value: null
      # Auto-execute spawn_agent for fix pass
      - action: call_mcp_tool
        server_name: gobby-agents
        tool_name: spawn_agent
        arguments:
          prompt: "You are a worker fixing code review deficiencies.\n\nIsolation: {{ variables.isolation_mode }}\nTask: {{ variables.current_task_id }}\nBranch: {{ variables.current_branch }}\n\nDeficiencies to fix:\n{% for d in variables.review_deficiencies %}- {{ d }}\n{% endfor %}\n\nActivate workflow, fix the issues, commit, close task, and report."
          agent: "{{ variables.agent_name }}"
          workflow: "worker"
          task_id: "{{ variables.current_task_id }}"
          isolation: "{{ variables.isolation_mode }}"
          branch_name: "{{ variables.current_branch }}"
          provider: "{{ variables.worker_provider }}"
          terminal: "{{ variables.worker_terminal }}"
          parent_session_id: "{{ session_id }}"
        output_as: _respawn_result
      # Extract new worker info from respawn result
      - action: set_variable
        name: current_worker_id
        value: "{{ variables._respawn_result.run_id if variables._respawn_result and variables._respawn_result.run_id is defined else '' }}"
      - action: set_variable
        name: current_clone_id
        value: "{{ variables._respawn_result.clone_id if variables._respawn_result and variables._respawn_result.clone_id is defined else '' }}"
      - action: set_variable
        name: current_worktree_id
        value: "{{ variables._respawn_result.worktree_id if variables._respawn_result and variables._respawn_result.worktree_id is defined else '' }}"
      # Clear deficiencies after respawn
      - action: set_variable
        name: review_deficiencies
        value: []

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit
      - Bash

    transitions:
      - to: wait_for_worker
        when: "variables.get('_respawn_result')"
      - to: find_work
        when: "not variables.get('_respawn_result')"

  - name: merge_clone
    description: "Merge approved clone branch into target"
    on_enter:
      - action: set_variable
        name: _merge_result
        value: null
      - action: call_mcp_tool
        server_name: gobby-clones
        tool_name: merge_clone_to_target
        arguments:
          clone_id: "{{ variables.current_clone_id }}"
          target_branch: "{{ variables.merge_target_branch }}"
        output_as: _merge_result
      - action: inject_message
        content: |
          ORCHESTRATOR: Merge result for clone {{ variables.current_clone_id }}.

          Check _merge_result for conflicts. If successful, proceed to cleanup.

    allowed_tools:
      - Bash
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: cleanup_clone
        when: "true"

  - name: merge_worktree
    description: "Merge approved worktree branch into dev"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Merging approved changes.

          Branch: {{ variables.current_branch }}
          Worktree: {{ variables.current_worktree_id }}

          Merge the branch into dev:

          1. Switch to main repo: cd /path/to/repo
          2. Squash merge: git merge --squash {{ variables.current_branch }}
          3. Commit: git commit -m "[{{ project.name }}-{{ variables.current_task_id }}] Merge from worktree"
          4. Or use worktree merge tool if available

    allowed_tools:
      - Bash
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: push_changes
        when: "true"

  - name: push_changes
    description: "Push merged changes to remote"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Pushing merged changes.

          Push the merged changes to the remote:

          git push

          If push fails due to upstream changes, pull and retry:
          git pull --rebase && git push

    allowed_tools:
      - Bash
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      # Route to correct cleanup by isolation mode
      - to: cleanup_worktree
        when: "variables.get('isolation_mode') == 'worktree'"
      - to: reset_state
        when: "variables.get('isolation_mode') == 'current'"

  - name: cleanup_clone
    description: "Delete clone and reset state"
    on_enter:
      - action: set_variable
        name: review_attempt
        value: 0
      - action: set_variable
        name: review_approved
        value: false
      - action: set_variable
        name: review_deficiencies
        value: []
      # Clear stale result
      - action: set_variable
        name: _cleanup_result
        value: null
      # Auto-execute delete_clone
      - action: call_mcp_tool
        server_name: gobby-clones
        tool_name: delete_clone
        arguments:
          clone_id: "{{ variables.current_clone_id }}"
        output_as: _cleanup_result
      # Clear worker variables
      - action: set_variable
        name: current_worker_id
        value: null
      - action: set_variable
        name: current_clone_id
        value: null
      - action: set_variable
        name: current_branch
        value: null

    allowed_tools:
      - Bash
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: find_work
        when: "true"

  - name: cleanup_worktree
    description: "Delete worktree and reset state"
    on_enter:
      - action: set_variable
        name: review_attempt
        value: 0
      - action: set_variable
        name: review_approved
        value: false
      - action: set_variable
        name: review_deficiencies
        value: []
      # Clear stale result
      - action: set_variable
        name: _cleanup_result
        value: null
      # Auto-execute delete_worktree
      - action: call_mcp_tool
        server_name: gobby-worktrees
        tool_name: delete_worktree
        arguments:
          worktree_id: "{{ variables.current_worktree_id }}"
        output_as: _cleanup_result
      # Clear worker variables
      - action: set_variable
        name: current_worker_id
        value: null
      - action: set_variable
        name: current_worktree_id
        value: null
      - action: set_variable
        name: current_branch
        value: null

    allowed_tools:
      - Bash
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - Read

    blocked_tools:
      - Edit
      - Write
      - NotebookEdit

    transitions:
      - to: find_work
        when: "true"

  - name: reset_state
    description: "Reset worker state (no isolation cleanup needed)"
    on_enter:
      - action: set_variable
        name: review_attempt
        value: 0
      - action: set_variable
        name: review_approved
        value: false
      - action: set_variable
        name: review_deficiencies
        value: []
      # Clear worker variables
      - action: set_variable
        name: current_worker_id
        value: null
      - action: set_variable
        name: current_branch
        value: null

    transitions:
      - to: find_work
        when: "true"

  - name: complete
    description: "All tasks done"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: All work complete!

          Session task {{ variables.session_task }} and all subtasks are closed.

          The meeseeks-box workflow will now exit.
          You may stop the session or start a new task.

exit_condition: "task_tree_complete(variables.session_task)"

on_premature_stop:
  action: guide_continuation
  message: |
    Task orchestration incomplete. Options:
    1. Continue working: use suggest_next_task() or wait for workers
    2. Stop anyway: first fetch schema, then call end_workflow:
       mcp__gobby__get_tool_schema(server_name="gobby-workflows", tool_name="end_workflow")
       mcp__gobby__call_tool(server_name="gobby-workflows", tool_name="end_workflow", arguments={"session_id": "<your_session_id>"})
