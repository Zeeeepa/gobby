name: meeseeks-box
description: |
  Interactive orchestrator for Claude Code terminal.

  This step workflow runs in Claude Code and:
  1. Finds ready tasks using suggest_next_task() (with leaf task fallback)
  2. Spawns a worker in an isolated environment (clone, worktree, or current)
  3. Waits for task completion using wait_for_task()
  4. Reviews code changes (with approval gate + respawn loop)
  5. Merges approved branch via mode-appropriate method
  6. Cleans up isolation environment, loops until all tasks complete

  Leaf task handling: When session_task is a leaf task (no children),
  suggest_next_task returns nothing. The workflow detects this and assigns
  the session_task directly to a worker instead of falling into idle wait.

  Isolation modes:
  - clone:    Worker runs in a full git clone (default). Merge via gobby-clones.
  - worktree: Worker runs in a git worktree. Merge via git squash-merge + push.
  - current:  Worker runs in the current working tree. No merge/cleanup needed.

  Sequential flow: one worker at a time. Each task goes through the full
  find → spawn → wait → review → merge → cleanup cycle before the next.

  Usage:
    1. Create/claim a parent task via gobby-tasks
    2. Activate this workflow with session_task set to the task ID(s)
    3. Optionally set isolation_mode variable ("clone", "worktree", or "current")
    4. Workflow spawns one worker per ready subtask sequentially
    5. Reviews changes, merges approved work, loops
    6. Exits when task tree is complete

version: "1.0"
type: step

variables:
  agent_name: null                # Set by spawn_agent (e.g., "meeseeks-gemini", "meeseeks-claude")
  session_task: null              # Root task ID(s) to complete
  isolation_mode: "clone"         # "clone", "worktree", or "current"
  current_worker_id: null         # Active worker run_id
  current_clone_id: null          # Active clone (when isolation_mode=clone)
  current_worktree_id: null       # Active worktree (when isolation_mode=worktree)
  current_branch: null            # Active branch name
  current_task_id: null           # Task being worked
  worker_provider: "gemini"
  worker_terminal: "tmux"
  worker_timeout: 600
  max_wait_retries: 3             # Max timeout retries in wait_for_worker
  wait_retry_count: 0             # Current timeout retry count
  max_review_attempts: 3
  review_attempt: 0
  review_approved: false
  review_deficiencies: []
  merge_target_branch: "dev"

steps:
  - name: find_work
    description: "Find next ready task using suggest_next_task() with leaf task fallback"
    status_message: "Finding next ready task for {{ variables.session_task }}..."
    on_enter:
      # Reset wait retry counter on re-entry
      - action: set_variable
        name: wait_retry_count
        value: 0
      # Clear stale results from previous iteration
      - action: set_variable
        name: _suggest_result
        value: null
      - action: set_variable
        name: current_task_id
        value: null
      - action: set_variable
        name: _session_task_info
        value: null

      # Step 1: Try suggest_next_task (finds ready subtasks for parent tasks)
      - action: call_mcp_tool
        server_name: gobby-tasks
        tool_name: suggest_next_task
        arguments:
          session_id: "{{ session_id }}"
        output_as: _suggest_result
      # Capture any error from suggest_next_task
      - action: set_variable
        name: _suggest_error
        value: "{{ variables._suggest_result.error if variables._suggest_result and variables._suggest_result.error is defined else '' }}"
      # Extract task_id from result
      - action: set_variable
        name: current_task_id
        value: "{{ variables._suggest_result.suggestion.ref if variables._suggest_result and variables._suggest_result.suggestion is defined and variables._suggest_result.suggestion.ref is defined else '' }}"

      # Step 2: Fallback — if suggest found nothing but session_task is set,
      # check if session_task itself is still open and assign it directly.
      # Handles leaf tasks (no children) and parents whose children are all done.
      - action: call_mcp_tool
        when: "not variables.get('current_task_id') and variables.get('session_task')"
        server_name: gobby-tasks
        tool_name: get_task
        arguments:
          task_id: "{{ variables.session_task }}"
        output_as: _session_task_info

      - action: set_variable
        name: current_task_id
        value: >-
          {{ variables.session_task
             if (not variables.get('current_task_id')
                 and variables.get('_session_task_info')
                 and variables._session_task_info.get('status') == 'open')
             else variables.get('current_task_id', '') }}

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read
      - Glob
      - Grep

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      - to: spawn_worker
        when: "variables.get('current_task_id')"
      # No ready tasks and tree not complete — wait for in-progress tasks
      - to: wait_for_worker
        when: "not variables.get('current_task_id')"

  - name: spawn_worker
    description: "Spawn worker in isolated environment"
    status_message: >-
      Spawning {{ variables.agent_name }} worker
      for task {{ variables.current_task_id }}
      ({{ variables.isolation_mode }} isolation)
    on_enter:
      # Clear stale result
      - action: set_variable
        name: _spawn_result
        value: null
      - action: set_variable
        name: current_worker_id
        value: null
      # Auto-execute spawn_agent
      - action: call_mcp_tool
        server_name: gobby-agents
        tool_name: spawn_agent
        arguments:
          prompt: "You are a worker in an isolated environment.\n\nFIRST, activate your workflow by calling:\n\nmcp__gobby__call_tool(\n  server_name=\"gobby-workflows\",\n  tool_name=\"activate_workflow\",\n  arguments={\n    \"name\": \"{{ variables.agent_name }}:worker\",\n    \"session_id\": \"<your_gobby_session_id>\",\n    \"variables\": {\"assigned_task_id\": \"{{ variables.current_task_id }}\"}\n  }\n)\n\nReplace <your_gobby_session_id> with your Gobby Session ID (shown at startup).\n\nThe workflow will guide you through: claim -> implement -> commit -> close -> report -> shutdown.\n\nDo NOT proceed without activating the workflow first."
          agent: "{{ variables.agent_name }}"
          workflow: "worker"
          task_id: "{{ variables.current_task_id }}"
          isolation: "{{ variables.isolation_mode }}"
          provider: "{{ variables.worker_provider }}"
          terminal: "{{ variables.worker_terminal }}"
          parent_session_id: "{{ session_id }}"
        output_as: _spawn_result
      # Extract worker info from result
      - action: set_variable
        name: current_worker_id
        value: "{{ variables._spawn_result.run_id if variables._spawn_result and variables._spawn_result.run_id is defined else '' }}"
      - action: set_variable
        name: current_clone_id
        value: "{{ variables._spawn_result.clone_id if variables._spawn_result and variables._spawn_result.clone_id is defined else '' }}"
      - action: set_variable
        name: current_worktree_id
        value: "{{ variables._spawn_result.worktree_id if variables._spawn_result and variables._spawn_result.worktree_id is defined else '' }}"
      - action: set_variable
        name: current_branch
        value: "{{ variables._spawn_result.branch_name if variables._spawn_result and variables._spawn_result.branch_name is defined else '' }}"

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    transitions:
      - to: wait_for_worker
        when: "variables.get('current_worker_id')"
      - to: find_work
        when: "not variables.get('current_worker_id')"

  - name: wait_for_worker
    description: "Wait for task completion or timeout"
    status_message: >-
      Waiting for task {{ variables.current_task_id }}
      (worker: {{ variables.current_worker_id }},
      timeout: {{ variables.worker_timeout }}s)
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Waiting for worker to complete.

          Task: {{ variables.current_task_id }}
          Worker: {{ variables.current_worker_id }}
          Timeout: {{ variables.worker_timeout }} seconds
          Wait attempt: {{ variables.wait_retry_count + 1 }} / {{ variables.max_wait_retries }}

          Wait for the task to be closed:

          mcp__gobby__call_tool(
            server_name="gobby-orchestration",
            tool_name="wait_for_task",
            arguments={
              "task_id": "{{ variables.current_task_id }}",
              "timeout": {{ variables.worker_timeout }}
            }
          )

          The wait returns:
          - completed: true if task reached closed/review status
          - timed_out: true if timeout reached

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_tools
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools

    transitions:
      - to: complete
        when: "task_tree_complete(variables.session_task)"
      # Task completed — proceed to code review
      - to: code_review
        when: "mcp_result_has('gobby-orchestration', 'wait_for_task', 'completed', true)"
      # Timed out but under max retries — increment counter and self-loop
      - to: wait_for_worker
        when: "mcp_result_has('gobby-orchestration', 'wait_for_task', 'timed_out', true) and variables.get('wait_retry_count', 0) < variables.get('max_wait_retries', 3)"
        on_transition:
          - action: set_variable
            name: wait_retry_count
            value: "{{ (variables.get('wait_retry_count', 0) | int) + 1 }}"
      # Timed out and max retries exceeded — skip to cleanup
      - to: cleanup
        when: "mcp_result_has('gobby-orchestration', 'wait_for_task', 'timed_out', true)"

  - name: code_review
    description: "Review worker's code changes"
    status_message: "Reviewing changes on branch {{ variables.current_branch }} for task {{ variables.current_task_id }}"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: Code review phase.

          Task: {{ variables.current_task_id }}
          Branch: {{ variables.current_branch }}
          Isolation: {{ variables.isolation_mode }}
          {% if variables.isolation_mode == 'clone' %}Clone: {{ variables.current_clone_id }}{% endif %}
          {% if variables.isolation_mode == 'worktree' %}Worktree: {{ variables.current_worktree_id }}{% endif %}
          Review attempt: {{ variables.review_attempt + 1 }} / {{ variables.max_review_attempts }}

          Review the worker's changes:

          1. Check the diff:
             git diff main...{{ variables.current_branch }}

          2. Review code quality, tests, security

          3. If approved, set review_approved to true and proceed to merge
          4. If deficiencies found, list them and respawn worker for fixes

          Use the workflow tools to set variables:
          - For approval: set_workflow_variable("review_approved", true)
          - For deficiencies: set_workflow_variable("review_deficiencies", ["list", "of", "issues"])

    allowed_tools:
      - Bash
      - Read
      - Glob
      - Grep
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools

    transitions:
      # Approved — proceed to unified merge
      - to: merge
        when: "variables.get('review_approved', False)"
      # Deficiencies found but retries remain — respawn for fixes
      - to: respawn_for_fixes
        when: "len(variables.get('review_deficiencies', [])) > 0 and variables.get('review_attempt', 0) < variables.get('max_review_attempts', 3)"
      # Deficiencies found and max retries exceeded — skip merge, cleanup
      - to: cleanup
        when: "len(variables.get('review_deficiencies', [])) > 0 and variables.get('review_attempt', 0) >= variables.get('max_review_attempts', 3)"

  - name: respawn_for_fixes
    description: "Respawn worker to fix deficiencies"
    status_message: "Respawning worker for task {{ variables.current_task_id }} (attempt {{ variables.review_attempt + 1 }}/{{ variables.max_review_attempts }})"
    on_enter:
      - action: set_variable
        name: review_attempt
        value: "{{ variables.review_attempt + 1 }}"
      - action: set_variable
        name: review_approved
        value: false
      # Clear stale result
      - action: set_variable
        name: _respawn_result
        value: null
      # Auto-execute spawn_agent for fix pass
      - action: call_mcp_tool
        server_name: gobby-agents
        tool_name: spawn_agent
        arguments:
          prompt: "You are a worker fixing code review deficiencies.\n\nIsolation: {{ variables.isolation_mode }}\nTask: {{ variables.current_task_id }}\nBranch: {{ variables.current_branch }}\n\nDeficiencies to fix:\n{% for d in variables.review_deficiencies %}- {{ d }}\n{% endfor %}\n\nActivate workflow, fix the issues, commit, close task, and report."
          agent: "{{ variables.agent_name }}"
          workflow: "worker"
          task_id: "{{ variables.current_task_id }}"
          isolation: "{{ variables.isolation_mode }}"
          branch_name: "{{ variables.current_branch }}"
          provider: "{{ variables.worker_provider }}"
          terminal: "{{ variables.worker_terminal }}"
          parent_session_id: "{{ session_id }}"
        output_as: _respawn_result
      # Extract new worker info from respawn result
      - action: set_variable
        name: current_worker_id
        value: "{{ variables._respawn_result.run_id if variables._respawn_result and variables._respawn_result.run_id is defined else '' }}"
      - action: set_variable
        name: current_clone_id
        value: "{{ variables._respawn_result.clone_id if variables._respawn_result and variables._respawn_result.clone_id is defined else '' }}"
      - action: set_variable
        name: current_worktree_id
        value: "{{ variables._respawn_result.worktree_id if variables._respawn_result and variables._respawn_result.worktree_id is defined else '' }}"
      # Clear deficiencies after respawn
      - action: set_variable
        name: review_deficiencies
        value: []

    allowed_tools:
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools
      - Read

    transitions:
      - to: wait_for_worker
        when: "variables.get('current_worker_id')"
      - to: find_work
        when: "not variables.get('current_worker_id')"

  - name: merge
    description: "Merge approved branch into target (unified across isolation modes)"
    status_message: "Merging branch {{ variables.current_branch }} into {{ variables.merge_target_branch }}"
    on_enter:
      - action: set_variable
        name: _merge_result
        value: null

      # Clone mode: merge via gobby-clones MCP tool
      - action: call_mcp_tool
        when: "variables.get('isolation_mode') == 'clone'"
        server_name: gobby-clones
        tool_name: merge_clone_to_target
        arguments:
          clone_id: "{{ variables.current_clone_id }}"
          target_branch: "{{ variables.merge_target_branch }}"
        output_as: _merge_result

      # Worktree mode: instruct LLM to do git merge (preserves worker commits)
      - action: inject_message
        when: "variables.get('isolation_mode') == 'worktree'"
        content: |
          ORCHESTRATOR: Merge worktree branch.

          Branch: {{ variables.current_branch }}
          Target: {{ variables.merge_target_branch }}
          Worktree: {{ variables.current_worktree_id }}

          Execute the merge (preserves worker commit history):

          git checkout {{ variables.merge_target_branch }}
          git merge {{ variables.current_branch }}
          git push

          After successful merge and push, set _merge_result to signal completion:
          set_workflow_variable("_merge_result", {"success": true})

      # Current mode: just push (changes are already in working tree)
      - action: inject_message
        when: "variables.get('isolation_mode') == 'current'"
        content: |
          ORCHESTRATOR: Push changes.

          Changes are already in the current working tree.

          git push

          If push fails due to upstream changes:
          git pull --rebase && git push

          After successful push, set _merge_result to signal completion:
          set_workflow_variable("_merge_result", {"success": true})

    allowed_tools:
      - Bash
      - Read
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools

    transitions:
      # All modes: transition after merge completes (_merge_result set by
      # call_mcp_tool for clone mode, or by LLM via set_variable for worktree/current)
      - to: cleanup
        when: "variables.get('_merge_result')"

  - name: cleanup
    description: "Clean up isolation environment and reset state (unified across modes)"
    status_message: "Cleaning up {{ variables.isolation_mode }} environment"
    on_enter:
      # Reset review state
      - action: set_variable
        name: review_attempt
        value: 0
      - action: set_variable
        name: review_approved
        value: false
      - action: set_variable
        name: review_deficiencies
        value: []
      # Clear stale result
      - action: set_variable
        name: _cleanup_result
        value: null

      # Clone mode: delete the clone
      - action: call_mcp_tool
        when: "variables.get('isolation_mode') == 'clone'"
        server_name: gobby-clones
        tool_name: delete_clone
        arguments:
          clone_id: "{{ variables.current_clone_id }}"
        output_as: _cleanup_result

      # Worktree mode: delete the worktree
      - action: call_mcp_tool
        when: "variables.get('isolation_mode') == 'worktree'"
        server_name: gobby-worktrees
        tool_name: delete_worktree
        arguments:
          worktree_id: "{{ variables.current_worktree_id }}"
        output_as: _cleanup_result

      # Current mode: no cleanup needed
      - action: set_variable
        when: "variables.get('isolation_mode') == 'current'"
        name: _cleanup_result
        value: "noop"

      # Clear worker variables
      - action: set_variable
        name: current_worker_id
        value: null
      - action: set_variable
        name: current_clone_id
        value: null
      - action: set_variable
        name: current_worktree_id
        value: null
      - action: set_variable
        name: current_branch
        value: null

    allowed_tools:
      - Bash
      - Read
      - mcp__gobby__call_tool
      - mcp__gobby__list_tools
      - mcp__gobby__get_tool_schema
      - mcp__gobby__list_mcp_servers
      - mcp__gobby__search_tools

    transitions:
      - to: find_work
        when: "true"

  - name: complete
    description: "All tasks done"
    status_message: "All tasks complete for {{ variables.session_task }}"
    on_enter:
      - action: inject_message
        content: |
          ORCHESTRATOR: All work complete!

          Session task {{ variables.session_task }} and all subtasks are closed.

          The meeseeks-box workflow will now exit.
          You may stop the session or start a new task.

exit_condition: "task_tree_complete(variables.session_task)"

on_premature_stop:
  action: guide_continuation
  message: |
    Task orchestration incomplete. Options:
    1. Continue working: use suggest_next_task() or wait for workers
    2. Stop anyway: first fetch schema, then call end_workflow:
       mcp__gobby__get_tool_schema(server_name="gobby-workflows", tool_name="end_workflow")
       mcp__gobby__call_tool(server_name="gobby-workflows", tool_name="end_workflow", arguments={"session_id": "<your_session_id>"})
