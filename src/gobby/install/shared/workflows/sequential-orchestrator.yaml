name: sequential-orchestrator
description: |
  Sequential multi-agent orchestration workflow.

  Manages sequential task execution with the following steps:
  1. select_task: Choose the next ready task from the task tree
  2. spawn_agent: Spawn an agent to work on the selected task
  3. wait: Wait for the spawned agent to complete
  4. review: Review the completed work
  5. decide: Decide whether to continue or complete
  6. loop: Check for more tasks and loop back or complete

  Features:
  - Sequential task processing (one at a time)
  - Agent spawning in worktrees
  - Automatic task selection based on dependencies
  - Review step for quality checks
  - Exit condition based on task tree completion

version: "1.0"
type: step

variables:
  session_task: null          # Epic/parent task ID
  target_branch: "dev"        # Branch to merge into
  worktree_id: null           # Created worktree ID
  worktree_path: null         # Path to worktree
  coding_provider: "gemini"   # Provider for subtasks
  spawn_mode: "terminal"      # Mode for spawning subagents
  current_agent_run_id: null  # Track spawned agent
  current_task_id: null       # Currently selected task

steps:
  - name: select_task
    description: "Select the next ready task from the task tree"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Selecting next task.

          Use suggest_next_task(session_id=<your_session_id>) to find the next
          ready subtask of {{ variables.session_task }}.

          If a task is available:
          - Store the task_id in current_task_id variable
          - Transition to 'spawn_agent' step

          If no tasks are ready:
          - Check if all tasks are complete
          - Transition to 'loop' to evaluate

    allowed_tools: all

    transitions:
      - to: spawn_agent
        when: "variables.current_task_id is not None"
      - to: loop
        when: "variables.current_task_id is None"

  - name: spawn_agent
    description: "Spawn an agent to work on the selected task"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Spawning agent for task.

          Task: {{ variables.current_task_id }}
          Provider: {{ variables.coding_provider }}
          Mode: {{ variables.spawn_mode }}
          Worktree: {{ variables.worktree_path }}

          Use start_agent() with:
          - provider: {{ variables.coding_provider }}
          - mode: {{ variables.spawn_mode }}
          - project_path: {{ variables.worktree_path }}
          - task: {{ variables.current_task_id }}
          - workflow: "worktree-agent"

          Store the run_id in current_agent_run_id variable.

    allowed_tools: all

    transitions:
      - to: wait
        when: "variables.current_agent_run_id is not None"

  - name: wait
    description: "Wait for the spawned agent to complete"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Waiting for agent.

          Agent run_id: {{ variables.current_agent_run_id }}

          Poll with get_agent_result(run_id="{{ variables.current_agent_run_id }}")

          When agent completes (status: success/error/timeout):
          - Note the result
          - Clear current_agent_run_id
          - Transition to 'review' step

    allowed_tools: all

    transitions:
      - to: review
        when: "variables.current_agent_run_id is None"

  - name: review
    description: "Review the completed work"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Reviewing completed work.

          Task: {{ variables.current_task_id }}
          Worktree: {{ variables.worktree_path }}

          Review the changes:
          1. Check git log for recent commits
          2. Verify task requirements were met
          3. Note any issues or follow-ups needed

          When review is complete, transition to 'decide'.

    allowed_tools: all

    transitions:
      - to: decide
        when: "true"

  - name: decide
    description: "Decide whether to continue or complete"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Deciding next action.

          Just completed: {{ variables.current_task_id }}

          Clear the current_task_id and transition to 'loop'
          to check for more tasks.

    allowed_tools: all

    transitions:
      - to: loop
        when: "true"

  - name: loop
    description: "Check for more tasks and loop or complete"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Checking task status.

          Epic: {{ variables.session_task }}

          Check if there are more ready tasks:
          - Use list_ready_tasks() or suggest_next_task()
          - If tasks available: go to 'select_task'
          - If no tasks and tree complete: go to 'complete'

    allowed_tools: all

    transitions:
      - to: select_task
        when: "has_ready_tasks(variables.session_task)"
      - to: complete
        when: "not has_ready_tasks(variables.session_task)"

  - name: complete
    description: "Orchestration complete - all tasks done"
    on_enter:
      - action: inject_message
        content: |
          SEQUENTIAL ORCHESTRATOR: Complete!

          All subtasks of {{ variables.session_task }} have been processed.

          Worktree: {{ variables.worktree_path }}

          The orchestration is complete. You may now:
          - Review the final state
          - Merge the worktree if appropriate
          - Close the epic task

exit_condition: "task_tree_complete(variables.session_task)"

on_premature_stop:
  action: guide_continuation
  message: |
    You cannot stop yet. The epic task tree is not complete.

    Current state:
    - Epic: {{ variables.session_task }}
    - Worktree: {{ variables.worktree_path }}
    - Current task: {{ variables.current_task_id }}
    - Current agent: {{ variables.current_agent_run_id }}

    If an agent is running, wait for it to complete.
    If no agent is running, select the next task.
    Continue until task_tree_complete({{ variables.session_task }}).
