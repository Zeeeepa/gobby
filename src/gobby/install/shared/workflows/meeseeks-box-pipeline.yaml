name: meeseeks-box-pipeline
description: |
  Automated orchestrator pipeline for daemon background execution.

  This pipeline workflow runs in the Gobby daemon and:
  1. Finds ready tasks using CLI commands
  2. Spawns Gemini workers via LLM prompt steps
  3. Waits for task completion
  4. Reviews code changes with approval gate
  5. Merges approved branches, cleans up worktrees
  6. Loops via recursive invocation

  Unlike the step workflow (meeseeks-box.yaml), this pipeline:
  - Uses your configured LLM providers (Claude/Gemini subscription)
  - Has native approval gates with tokens
  - Runs sequentially and deterministically
  - Is suitable for CI/CD-like automation

  Usage:
    gobby pipelines run meeseeks-box-pipeline -i session_task="#123"

version: "1.0"
type: pipeline

inputs:
  agent_name: "meeseeks-box-pipeline"             # Agent definition name (e.g., "meeseeks-gemini", "meeseeks-claude"). Must not be null â€” pipeline will fail at spawn step if unset.
  session_task: null           # Root task ID to complete
  max_review_attempts: 3       # Max times to request changes per task
  wait_timeout: 600            # 10 min per wait cycle
  max_inactive_waits: 3        # End workflow after N timeouts with no activity
  max_iterations: 50           # Maximum recursive iterations to prevent infinite loops
  _current_iteration: 0        # Internal counter (do not set manually)

steps:
  # Guard against infinite recursion
  - id: check_iteration_limit
    condition: "${{ inputs._current_iteration >= inputs.max_iterations }}"
    exec: "echo 'ERROR: Maximum iteration limit reached ({{ inputs.max_iterations }})' && exit 1"

  # Find next ready task
  - id: find_work
    exec: gobby task suggest --session-task "${{ inputs.session_task }}" --json

  # Spawn Gemini worker in worktree
  - id: spawn_worker
    condition: "${{ find_work.output.task_id }}"
    prompt: |
      Spawn a worker for task ${{ find_work.output.task_id }}:

      Use the spawn_agent MCP tool with these parameters:
      - agent: ${{ inputs.agent_name }}
      - workflow: worker
      - task_id: ${{ find_work.output.task_id }}
      - isolation: worktree

      The prompt should instruct the worker to:
      1. Activate the ${{ inputs.agent_name }}:worker workflow
      2. Claim the task
      3. Implement the changes
      4. Commit and close the task
      5. Report completion and shutdown

      Return the run_id, worktree_id, and branch_name from the spawn result.
    tools:
      - mcp__gobby__call_tool

  # Wait for worker to complete
  - id: wait_for_worker
    condition: "${{ spawn_worker.output.run_id }}"
    exec: |
      gobby task wait \
        --task-id "${{ find_work.output.task_id }}" \
        --timeout ${{ inputs.wait_timeout }} \
        --json

  # Code review with APPROVAL GATE
  - id: code_review
    condition: "${{ wait_for_worker.output.completed }}"
    prompt: |
      Review the code changes in branch ${{ spawn_worker.output.branch_name }}:

      1. Run: git diff main...${{ spawn_worker.output.branch_name }}
      2. Check code quality and style
      3. Verify tests pass (if applicable)
      4. Check for security issues
      5. Review documentation

      Output your review findings:
      - If issues found, return: {"approved": false, "deficiencies": ["list", "of", "issues"]}
      - If approved, return: {"approved": true, "deficiencies": []}
    tools:
      - Bash
      - Read
      - Glob
      - Grep
    approval:
      required: true
      message: "Code review complete for task ${{ find_work.output.task_id }}. Approve merge to dev?"

  # Merge branch into dev (after approval)
  - id: merge
    condition: "${{ code_review.approved }}"
    exec: |
      cd "$(gobby worktree path --id '${{ spawn_worker.output.worktree_id }}')" && \
      git checkout dev && \
      git merge --squash ${{ spawn_worker.output.branch_name }} -m "[${{ find_work.output.task_id }}] Merge from worktree"

  # Cleanup worktree
  - id: cleanup
    exec: gobby worktree delete --id "${{ spawn_worker.output.worktree_id }}" --force

  # Check if more work to do
  - id: check_complete
    exec: gobby task tree-status --session-task "${{ inputs.session_task }}" --json

  # Recursive invocation for next task (if not complete)
  - id: next_iteration
    condition: "not ${{ check_complete.output.all_complete }}"
    invoke_pipeline: meeseeks-box-pipeline
    input: |
      {
        "session_task": "${{ inputs.session_task }}",
        "max_review_attempts": ${{ inputs.max_review_attempts }},
        "wait_timeout": ${{ inputs.wait_timeout }},
        "max_inactive_waits": ${{ inputs.max_inactive_waits }},
        "max_iterations": ${{ inputs.max_iterations }},
        "_current_iteration": ${{ inputs._current_iteration + 1 }}
      }

outputs:
  tasks_completed: ${{ check_complete.output.completed_count }}
  session_complete: ${{ check_complete.output.all_complete }}
  last_task: ${{ find_work.output.task_id }}
  last_branch: ${{ spawn_worker.output.branch_name }}
