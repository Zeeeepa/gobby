"""Tests for the git hooks installer module."""

import stat
import subprocess
from pathlib import Path
from unittest.mock import MagicMock, patch

from gobby.cli.installers.git_hooks import (
    GOBBY_HOOK_END,
    GOBBY_HOOK_START,
    HOOK_TEMPLATES,
    _backup_hook,
    _check_precommit_installed,
    _has_gobby_hook,
    _has_precommit_config,
    _is_precommit_framework_hook,
    _remove_gobby_section,
    _wrap_gobby_section,
    install_git_hooks,
    uninstall_git_hooks,
)


class TestHasGobbyHook:
    """Tests for _has_gobby_hook function."""

    def test_returns_true_when_marker_present(self):
        """Test that function returns True when Gobby marker is present."""
        content = f"""#!/bin/bash
{GOBBY_HOOK_START}
# some hook content
{GOBBY_HOOK_END}
"""
        assert _has_gobby_hook(content) is True

    def test_returns_false_when_marker_absent(self):
        """Test that function returns False when Gobby marker is absent."""
        content = """#!/bin/bash
# some other hook content
echo "hello"
"""
        assert _has_gobby_hook(content) is False

    def test_returns_false_for_empty_content(self):
        """Test that function returns False for empty content."""
        assert _has_gobby_hook("") is False

    def test_partial_marker_returns_false(self):
        """Test that partial marker doesn't match."""
        content = """#!/bin/bash
# >>> GOBBY
"""
        assert _has_gobby_hook(content) is False


class TestIsPrecommitFrameworkHook:
    """Tests for _is_precommit_framework_hook function."""

    def test_detects_precommit_generated_hook(self):
        """Test detection of pre-commit framework generated hook."""
        content = """#!/usr/bin/env python
# File generated by pre-commit: https://pre-commit.com
import sys
"""
        assert _is_precommit_framework_hook(content) is True

    def test_detects_precommit_module_usage(self):
        """Test detection of pre_commit module usage."""
        content = """#!/usr/bin/env python
import pre_commit
from pre_commit import main
"""
        assert _is_precommit_framework_hook(content) is True

    def test_returns_false_for_regular_hook(self):
        """Test that regular hooks are not detected as pre-commit."""
        content = """#!/bin/bash
echo "Running tests..."
npm test
"""
        assert _is_precommit_framework_hook(content) is False

    def test_returns_false_for_empty_content(self):
        """Test that empty content returns False."""
        assert _is_precommit_framework_hook("") is False


class TestWrapGobbySection:
    """Tests for _wrap_gobby_section function."""

    def test_wraps_script_with_markers(self):
        """Test that script is wrapped with start and end markers."""
        script = """
echo "hello"
"""
        result = _wrap_gobby_section(script)

        assert result.startswith(GOBBY_HOOK_START)
        assert result.endswith(GOBBY_HOOK_END + "\n")
        assert "echo \"hello\"" in result

    def test_strips_whitespace_from_script(self):
        """Test that leading/trailing whitespace is stripped."""
        script = """

   echo "test"

"""
        result = _wrap_gobby_section(script)

        # Should not have blank lines at start/end within markers
        lines = result.split("\n")
        assert lines[1] == "echo \"test\""

    def test_handles_multiline_script(self):
        """Test wrapping a multiline script."""
        script = """
line1
line2
line3
"""
        result = _wrap_gobby_section(script)

        assert "line1" in result
        assert "line2" in result
        assert "line3" in result


class TestRemoveGobbySection:
    """Tests for _remove_gobby_section function."""

    def test_removes_gobby_section_completely(self):
        """Test that Gobby section is removed completely."""
        content = f"""#!/bin/bash
echo "before"
{GOBBY_HOOK_START}
# gobby hook content
echo "gobby stuff"
{GOBBY_HOOK_END}
echo "after"
"""
        result = _remove_gobby_section(content)

        assert GOBBY_HOOK_START not in result
        assert GOBBY_HOOK_END not in result
        assert "gobby stuff" not in result
        assert "before" in result
        assert "after" in result

    def test_preserves_content_outside_section(self):
        """Test that content outside Gobby section is preserved."""
        content = f"""#!/bin/bash
echo "first"
{GOBBY_HOOK_START}
# gobby
{GOBBY_HOOK_END}
echo "second"
"""
        result = _remove_gobby_section(content)

        assert "first" in result
        assert "second" in result

    def test_handles_content_without_gobby_section(self):
        """Test handling content that has no Gobby section."""
        content = """#!/bin/bash
echo "no gobby here"
"""
        result = _remove_gobby_section(content)

        assert "no gobby here" in result

    def test_returns_empty_for_gobby_only_content(self):
        """Test that returns empty when only Gobby section exists."""
        content = f"""{GOBBY_HOOK_START}
# gobby content only
{GOBBY_HOOK_END}
"""
        result = _remove_gobby_section(content)

        assert result == ""

    def test_cleans_up_multiple_blank_lines(self):
        """Test that multiple consecutive blank lines are reduced."""
        content = f"""#!/bin/bash


{GOBBY_HOOK_START}
# gobby
{GOBBY_HOOK_END}



echo "after"
"""
        result = _remove_gobby_section(content)

        # Should not have more than 2 consecutive newlines
        assert "\n\n\n" not in result


class TestBackupHook:
    """Tests for _backup_hook function."""

    def test_creates_timestamped_backup(self, tmp_path: Path):
        """Test that backup is created with timestamp."""
        hooks_dir = tmp_path / "hooks"
        hooks_dir.mkdir()

        hook_path = hooks_dir / "pre-commit"
        hook_path.write_text("#!/bin/bash\necho 'original'")

        backup_path = _backup_hook(hook_path, hooks_dir)

        assert backup_path is not None
        assert Path(backup_path).exists()
        assert ".backup" in backup_path
        assert Path(backup_path).read_text() == "#!/bin/bash\necho 'original'"

    def test_returns_none_for_nonexistent_hook(self, tmp_path: Path):
        """Test that None is returned when hook doesn't exist."""
        hooks_dir = tmp_path / "hooks"
        hooks_dir.mkdir()

        hook_path = hooks_dir / "nonexistent"

        result = _backup_hook(hook_path, hooks_dir)

        assert result is None

    def test_backup_preserves_metadata(self, tmp_path: Path):
        """Test that backup preserves file metadata (copy2)."""
        hooks_dir = tmp_path / "hooks"
        hooks_dir.mkdir()

        hook_path = hooks_dir / "pre-commit"
        hook_path.write_text("#!/bin/bash")
        # Set specific permissions
        hook_path.chmod(stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP)

        backup_path = _backup_hook(hook_path, hooks_dir)

        assert backup_path is not None
        backup = Path(backup_path)
        # Permissions should be preserved
        original_mode = hook_path.stat().st_mode
        backup_mode = backup.stat().st_mode
        assert (original_mode & 0o777) == (backup_mode & 0o777)

    @patch("gobby.cli.installers.git_hooks.shutil.copy2")
    def test_handles_os_error_gracefully(
        self, mock_copy: MagicMock, tmp_path: Path
    ):
        """Test that OSError during backup is handled gracefully."""
        hooks_dir = tmp_path / "hooks"
        hooks_dir.mkdir()

        hook_path = hooks_dir / "pre-commit"
        hook_path.write_text("#!/bin/bash")

        mock_copy.side_effect = OSError("Permission denied")

        result = _backup_hook(hook_path, hooks_dir)

        assert result is None


class TestCheckPrecommitInstalled:
    """Tests for _check_precommit_installed function."""

    @patch("gobby.cli.installers.git_hooks.shutil.which")
    def test_returns_true_when_precommit_installed(self, mock_which: MagicMock):
        """Test returns True when pre-commit is in PATH."""
        mock_which.return_value = "/usr/local/bin/pre-commit"

        assert _check_precommit_installed() is True
        mock_which.assert_called_once_with("pre-commit")

    @patch("gobby.cli.installers.git_hooks.shutil.which")
    def test_returns_false_when_precommit_not_installed(
        self, mock_which: MagicMock
    ):
        """Test returns False when pre-commit is not in PATH."""
        mock_which.return_value = None

        assert _check_precommit_installed() is False


class TestHasPrecommitConfig:
    """Tests for _has_precommit_config function."""

    def test_returns_true_when_config_exists(self, tmp_path: Path):
        """Test returns True when .pre-commit-config.yaml exists."""
        config_file = tmp_path / ".pre-commit-config.yaml"
        config_file.write_text("repos: []")

        assert _has_precommit_config(tmp_path) is True

    def test_returns_false_when_config_missing(self, tmp_path: Path):
        """Test returns False when .pre-commit-config.yaml doesn't exist."""
        assert _has_precommit_config(tmp_path) is False


class TestInstallGitHooks:
    """Tests for install_git_hooks function."""

    def test_fails_if_not_git_repository(self, tmp_path: Path):
        """Test that installation fails if not in a git repository."""
        result = install_git_hooks(tmp_path)

        assert result["success"] is False
        assert "Not a git repository" in result["error"]

    def test_creates_hooks_directory_if_missing(self, tmp_path: Path):
        """Test that .git/hooks directory is created if missing."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()

        install_git_hooks(tmp_path)

        assert (git_dir / "hooks").exists()

    def test_installs_all_hook_types(self, tmp_path: Path):
        """Test that all hook types are installed."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        result = install_git_hooks(tmp_path)

        assert result["success"] is True
        assert set(result["installed"]) == set(HOOK_TEMPLATES.keys())

        for hook_name in HOOK_TEMPLATES:
            hook_path = hooks_dir / hook_name
            assert hook_path.exists()

    def test_hooks_are_executable(self, tmp_path: Path):
        """Test that installed hooks have executable permission."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        install_git_hooks(tmp_path)

        for hook_name in HOOK_TEMPLATES:
            hook_path = hooks_dir / hook_name
            mode = hook_path.stat().st_mode
            assert mode & stat.S_IXUSR  # User executable

    def test_hooks_have_bash_shebang(self, tmp_path: Path):
        """Test that hooks have proper bash shebang."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        install_git_hooks(tmp_path)

        for hook_name in HOOK_TEMPLATES:
            hook_path = hooks_dir / hook_name
            content = hook_path.read_text()
            assert content.startswith("#!/usr/bin/env bash")

    def test_skips_already_installed_hooks(self, tmp_path: Path):
        """Test that already installed hooks are skipped."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Install first time
        install_git_hooks(tmp_path)

        # Install second time
        result = install_git_hooks(tmp_path)

        assert result["success"] is True
        assert len(result["installed"]) == 0
        assert len(result["skipped"]) == len(HOOK_TEMPLATES)

        for skipped in result["skipped"]:
            assert "already installed" in skipped

    def test_force_reinstalls_existing_hooks(self, tmp_path: Path):
        """Test that force=True reinstalls existing hooks."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Install first time
        install_git_hooks(tmp_path)

        # Install with force
        result = install_git_hooks(tmp_path, force=True)

        assert result["success"] is True
        assert set(result["installed"]) == set(HOOK_TEMPLATES.keys())
        assert len(result["backups"]) > 0

    def test_chains_with_existing_hooks(self, tmp_path: Path):
        """Test that Gobby hooks chain with existing hooks."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create existing hook
        existing_hook = hooks_dir / "pre-commit"
        existing_hook.write_text("#!/bin/bash\necho 'existing hook'\n")
        existing_hook.chmod(stat.S_IRWXU)

        result = install_git_hooks(tmp_path)

        assert result["success"] is True

        content = existing_hook.read_text()
        # Should contain both original and Gobby sections
        assert "existing hook" in content
        assert GOBBY_HOOK_START in content

    def test_preserves_shebang_when_chaining(self, tmp_path: Path):
        """Test that existing shebang is preserved when chaining."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create existing hook with specific shebang
        existing_hook = hooks_dir / "post-merge"
        existing_hook.write_text("#!/usr/bin/env zsh\necho 'zsh hook'\n")

        install_git_hooks(tmp_path)

        content = existing_hook.read_text()
        # Should preserve the original shebang
        assert content.startswith("#!/usr/bin/env zsh")

    def test_creates_backup_before_modifying(self, tmp_path: Path):
        """Test that backup is created before modifying existing hook."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create existing hook
        existing_hook = hooks_dir / "pre-commit"
        original_content = "#!/bin/bash\necho 'original'\n"
        existing_hook.write_text(original_content)

        result = install_git_hooks(tmp_path, force=True)

        assert len(result["backups"]) > 0
        backup_path = result["backups"][0]
        assert Path(backup_path).read_text() == original_content

    def test_replaces_precommit_framework_hook(self, tmp_path: Path):
        """Test that pre-commit framework hook is replaced with wrapper."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create pre-commit framework generated hook
        precommit_hook = hooks_dir / "pre-commit"
        precommit_hook.write_text(
            "#!/usr/bin/env python\n# File generated by pre-commit\nimport pre_commit\n"
        )

        result = install_git_hooks(tmp_path)

        assert result["success"] is True

        content = precommit_hook.read_text()
        # Should replace entirely, not chain
        assert "File generated by pre-commit" not in content
        assert GOBBY_HOOK_START in content

    @patch("gobby.cli.installers.git_hooks._backup_hook")
    def test_continues_when_backup_fails(
        self, mock_backup: MagicMock, tmp_path: Path
    ):
        """Test that installation continues even when backup fails."""
        mock_backup.return_value = None  # Simulate backup failure

        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create existing hook
        existing_hook = hooks_dir / "pre-commit"
        existing_hook.write_text("#!/bin/bash\necho 'existing'\n")

        result = install_git_hooks(tmp_path, force=True)

        assert result["success"] is True
        assert "pre-commit" in result["installed"]
        # No backups should be recorded since backup failed
        assert len(result["backups"]) == 0

        # Hook should still be updated
        content = existing_hook.read_text()
        assert GOBBY_HOOK_START in content

    @patch("gobby.cli.installers.git_hooks._check_precommit_installed")
    @patch("gobby.cli.installers.git_hooks.subprocess.run")
    def test_installs_pre_push_hooks_when_precommit_available(
        self, mock_run: MagicMock, mock_check: MagicMock, tmp_path: Path
    ):
        """Test that pre-push hooks are installed via pre-commit when available."""
        mock_check.return_value = True
        mock_run.return_value = MagicMock(returncode=0)

        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create pre-commit config
        (tmp_path / ".pre-commit-config.yaml").write_text("repos: []")

        result = install_git_hooks(tmp_path, setup_precommit=True)

        assert result["success"] is True
        assert result["precommit_installed"] is True
        mock_run.assert_called_once()
        call_args = mock_run.call_args
        assert "pre-push" in call_args.args[0]

    @patch("gobby.cli.installers.git_hooks._check_precommit_installed")
    def test_skips_precommit_when_not_installed(
        self, mock_check: MagicMock, tmp_path: Path
    ):
        """Test that pre-commit setup is skipped when not installed."""
        mock_check.return_value = False

        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create pre-commit config (but pre-commit not installed)
        (tmp_path / ".pre-commit-config.yaml").write_text("repos: []")

        result = install_git_hooks(tmp_path, setup_precommit=True)

        assert result["success"] is True
        assert result["precommit_installed"] is False

    @patch("gobby.cli.installers.git_hooks._check_precommit_installed")
    def test_skips_precommit_when_config_missing(
        self, mock_check: MagicMock, tmp_path: Path
    ):
        """Test that pre-commit setup is skipped when config is missing."""
        mock_check.return_value = True

        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        result = install_git_hooks(tmp_path, setup_precommit=True)

        assert result["success"] is True
        assert result["precommit_installed"] is False

    def test_skips_precommit_when_setup_disabled(self, tmp_path: Path):
        """Test that pre-commit setup is skipped when disabled."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        (tmp_path / ".pre-commit-config.yaml").write_text("repos: []")

        result = install_git_hooks(tmp_path, setup_precommit=False)

        assert result["success"] is True
        assert result["precommit_installed"] is False

    @patch("gobby.cli.installers.git_hooks._check_precommit_installed")
    @patch("gobby.cli.installers.git_hooks.subprocess.run")
    def test_handles_precommit_install_timeout(
        self, mock_run: MagicMock, mock_check: MagicMock, tmp_path: Path
    ):
        """Test graceful handling of pre-commit install timeout."""
        mock_check.return_value = True
        mock_run.side_effect = subprocess.TimeoutExpired(cmd="pre-commit", timeout=30)

        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        (tmp_path / ".pre-commit-config.yaml").write_text("repos: []")

        result = install_git_hooks(tmp_path, setup_precommit=True)

        # Should still succeed even if pre-commit pre-push install times out
        # precommit_installed is True because pre-commit config was detected
        assert result["success"] is True
        assert result["precommit_installed"] is True

    @patch("gobby.cli.installers.git_hooks._check_precommit_installed")
    @patch("gobby.cli.installers.git_hooks.subprocess.run")
    def test_handles_precommit_install_subprocess_error(
        self, mock_run: MagicMock, mock_check: MagicMock, tmp_path: Path
    ):
        """Test graceful handling of subprocess error during pre-commit install."""
        mock_check.return_value = True
        mock_run.side_effect = subprocess.SubprocessError("Command failed")

        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        (tmp_path / ".pre-commit-config.yaml").write_text("repos: []")

        result = install_git_hooks(tmp_path, setup_precommit=True)

        # Should still succeed even if pre-commit install fails
        assert result["success"] is True

    def test_hook_content_includes_gobby_markers(self, tmp_path: Path):
        """Test that installed hooks contain Gobby markers."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        install_git_hooks(tmp_path)

        for hook_name in HOOK_TEMPLATES:
            hook_path = hooks_dir / hook_name
            content = hook_path.read_text()
            assert GOBBY_HOOK_START in content
            assert GOBBY_HOOK_END in content

    def test_adds_shebang_to_existing_hook_without_shebang(self, tmp_path: Path):
        """Test that shebang is added to existing hooks without one."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create existing hook without shebang
        existing_hook = hooks_dir / "post-checkout"
        existing_hook.write_text("echo 'no shebang'\n")

        install_git_hooks(tmp_path)

        content = existing_hook.read_text()
        # Should add shebang at start
        assert content.startswith("#!/usr/bin/env bash")

    def test_handles_empty_existing_hook(self, tmp_path: Path):
        """Test installing to an existing hook file that is empty."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create empty hook file
        empty_hook = hooks_dir / "post-merge"
        empty_hook.write_text("")

        result = install_git_hooks(tmp_path)

        assert result["success"] is True

        content = empty_hook.read_text()
        assert content.startswith("#!/usr/bin/env bash")
        assert GOBBY_HOOK_START in content

    def test_handles_whitespace_only_existing_hook(self, tmp_path: Path):
        """Test installing to an existing hook file with only whitespace."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create hook file with only whitespace
        whitespace_hook = hooks_dir / "post-checkout"
        whitespace_hook.write_text("   \n\n  \n")

        result = install_git_hooks(tmp_path)

        assert result["success"] is True

        content = whitespace_hook.read_text()
        assert content.startswith("#!/usr/bin/env bash")
        assert GOBBY_HOOK_START in content


class TestUninstallGitHooks:
    """Tests for uninstall_git_hooks function."""

    def test_fails_if_not_git_repository(self, tmp_path: Path):
        """Test that uninstallation fails if not in a git repository."""
        result = uninstall_git_hooks(tmp_path)

        assert result["success"] is False
        assert "Not a git repository" in result["error"]

    def test_succeeds_if_no_hooks_directory(self, tmp_path: Path):
        """Test that uninstallation succeeds if no hooks directory exists."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()

        result = uninstall_git_hooks(tmp_path)

        assert result["success"] is True

    def test_removes_gobby_section_from_hooks(self, tmp_path: Path):
        """Test that Gobby sections are removed from hooks."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Install hooks first
        install_git_hooks(tmp_path)

        # Uninstall
        result = uninstall_git_hooks(tmp_path)

        assert result["success"] is True
        assert set(result["removed"]) == set(HOOK_TEMPLATES.keys())

    def test_preserves_other_hook_content(self, tmp_path: Path):
        """Test that non-Gobby hook content is preserved."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create hook with existing content
        existing_hook = hooks_dir / "pre-commit"
        existing_hook.write_text("#!/bin/bash\necho 'existing'\n")

        # Install Gobby hooks
        install_git_hooks(tmp_path)

        # Verify combined content
        content_before = existing_hook.read_text()
        assert "existing" in content_before
        assert GOBBY_HOOK_START in content_before

        # Uninstall
        result = uninstall_git_hooks(tmp_path)

        assert result["success"] is True

        content_after = existing_hook.read_text()
        assert "existing" in content_after
        assert GOBBY_HOOK_START not in content_after

    def test_removes_gobby_content_leaves_shebang(self, tmp_path: Path):
        """Test that hooks with only Gobby content have Gobby removed but shebang retained."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Install hooks (creates hooks with shebang + Gobby content)
        install_git_hooks(tmp_path)

        # Verify hooks exist
        for hook_name in HOOK_TEMPLATES:
            assert (hooks_dir / hook_name).exists()

        # Uninstall
        uninstall_git_hooks(tmp_path)

        # Hooks should still exist but only contain shebang (non-empty content)
        for hook_name in HOOK_TEMPLATES:
            hook_path = hooks_dir / hook_name
            assert hook_path.exists()
            content = hook_path.read_text()
            assert GOBBY_HOOK_START not in content
            assert content.strip() == "#!/usr/bin/env bash"

    def test_reports_not_found_hooks(self, tmp_path: Path):
        """Test that non-existent hooks are reported as not found."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        result = uninstall_git_hooks(tmp_path)

        assert result["success"] is True
        assert set(result["not_found"]) == set(HOOK_TEMPLATES.keys())

    def test_removes_hook_file_when_empty_after_uninstall(self, tmp_path: Path):
        """Test that hook file is deleted when it becomes completely empty."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create a hook file that contains ONLY gobby section (no shebang)
        # This is a contrived case but tests the code path
        hook_path = hooks_dir / "pre-commit"
        gobby_content = f"{GOBBY_HOOK_START}\n# gobby stuff\n{GOBBY_HOOK_END}\n"
        hook_path.write_text(gobby_content)

        result = uninstall_git_hooks(tmp_path)

        assert result["success"] is True
        assert "pre-commit" in result["removed"]
        # Hook should be deleted since it's now empty
        assert not hook_path.exists()

    def test_reports_hooks_without_gobby_section(self, tmp_path: Path):
        """Test that hooks without Gobby section are reported as not found."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create hook without Gobby section
        hook = hooks_dir / "pre-commit"
        hook.write_text("#!/bin/bash\necho 'no gobby'\n")

        result = uninstall_git_hooks(tmp_path)

        assert result["success"] is True
        assert "pre-commit" in result["not_found"]


class TestHookTemplates:
    """Tests for HOOK_TEMPLATES constant."""

    def test_all_expected_hooks_defined(self):
        """Test that all expected hook types are defined."""
        expected_hooks = {"pre-commit", "post-merge", "post-checkout"}
        assert set(HOOK_TEMPLATES.keys()) == expected_hooks

    def test_precommit_template_contains_gobby_sync(self):
        """Test that pre-commit template contains gobby task sync."""
        assert "gobby tasks sync" in HOOK_TEMPLATES["pre-commit"]
        assert "--export" in HOOK_TEMPLATES["pre-commit"]

    def test_postmerge_template_contains_gobby_sync(self):
        """Test that post-merge template contains gobby task sync."""
        assert "gobby tasks sync" in HOOK_TEMPLATES["post-merge"]
        assert "--import" in HOOK_TEMPLATES["post-merge"]

    def test_postcheckout_template_contains_gobby_sync(self):
        """Test that post-checkout template contains gobby task sync."""
        assert "gobby tasks sync" in HOOK_TEMPLATES["post-checkout"]
        assert "--import" in HOOK_TEMPLATES["post-checkout"]

    def test_postcheckout_only_runs_on_branch_checkout(self):
        """Test that post-checkout only syncs on branch checkouts."""
        # $3 is 1 for branch checkout, 0 for file checkout
        assert '"$3" = "1"' in HOOK_TEMPLATES["post-checkout"]


class TestMarkerConstants:
    """Tests for marker constants."""

    def test_start_marker_format(self):
        """Test that start marker has expected format."""
        assert ">>>" in GOBBY_HOOK_START
        assert "GOBBY" in GOBBY_HOOK_START

    def test_end_marker_format(self):
        """Test that end marker has expected format."""
        assert "<<<" in GOBBY_HOOK_END
        assert "GOBBY" in GOBBY_HOOK_END

    def test_markers_are_different(self):
        """Test that start and end markers are different."""
        assert GOBBY_HOOK_START != GOBBY_HOOK_END


class TestIntegration:
    """Integration tests for full install/uninstall cycle."""

    def test_install_uninstall_cycle_clean_repo(self, tmp_path: Path):
        """Test full install/uninstall cycle on a clean repository."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Install
        install_result = install_git_hooks(tmp_path)
        assert install_result["success"] is True
        assert len(install_result["installed"]) == len(HOOK_TEMPLATES)

        # Verify hooks exist
        for hook_name in HOOK_TEMPLATES:
            assert (hooks_dir / hook_name).exists()

        # Uninstall
        uninstall_result = uninstall_git_hooks(tmp_path)
        assert uninstall_result["success"] is True
        assert len(uninstall_result["removed"]) == len(HOOK_TEMPLATES)

        # Verify Gobby content is removed from hooks
        # Note: Hooks still exist with just shebang since the uninstall preserves
        # non-empty content (the shebang that was added during install)
        for hook_name in HOOK_TEMPLATES:
            hook_path = hooks_dir / hook_name
            content = hook_path.read_text()
            assert GOBBY_HOOK_START not in content
            assert GOBBY_HOOK_END not in content

    def test_install_uninstall_preserves_existing_hooks(self, tmp_path: Path):
        """Test that install/uninstall preserves existing hook content."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Create existing hook with custom content
        original_content = "#!/bin/bash\n\nrun_tests() {\n    pytest\n}\n\nrun_tests\n"
        existing_hook = hooks_dir / "pre-commit"
        existing_hook.write_text(original_content)
        existing_hook.chmod(stat.S_IRWXU)

        # Install
        install_git_hooks(tmp_path)

        # Verify Gobby was added
        content = existing_hook.read_text()
        assert GOBBY_HOOK_START in content
        assert "run_tests" in content

        # Uninstall
        uninstall_git_hooks(tmp_path)

        # Verify original content preserved (minus some whitespace normalization)
        final_content = existing_hook.read_text()
        assert GOBBY_HOOK_START not in final_content
        assert "run_tests" in final_content
        assert "pytest" in final_content

    def test_force_reinstall_updates_content(self, tmp_path: Path):
        """Test that force reinstall updates hook content."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Install
        install_git_hooks(tmp_path)

        # Modify the installed hook
        hook_path = hooks_dir / "pre-commit"
        original_content = hook_path.read_text()
        hook_path.write_text(original_content + "\n# manually added\n")

        # Force reinstall
        result = install_git_hooks(tmp_path, force=True)

        assert result["success"] is True
        assert "pre-commit" in result["installed"]

        # Verify content was updated (manually added comment still present due to chaining)
        new_content = hook_path.read_text()
        assert GOBBY_HOOK_START in new_content

    def test_multiple_install_operations_idempotent(self, tmp_path: Path):
        """Test that multiple installs are idempotent."""
        git_dir = tmp_path / ".git"
        git_dir.mkdir()
        hooks_dir = git_dir / "hooks"
        hooks_dir.mkdir()

        # Install multiple times
        for _ in range(3):
            result = install_git_hooks(tmp_path)
            assert result["success"] is True

        # Verify only one Gobby section exists
        for hook_name in HOOK_TEMPLATES:
            hook_path = hooks_dir / hook_name
            content = hook_path.read_text()
            assert content.count(GOBBY_HOOK_START) == 1
            assert content.count(GOBBY_HOOK_END) == 1
