name: plan-to-tasks
description: "Decompose a plan into atomic tasks and execute sequentially with persistent tracking"
type: step
version: "2.0"

variables:
  plan_pattern: "**/*.plan.md"
  max_tasks: 20
  require_task_approval: false

steps:
  - name: decompose
    description: "Break plan into atomic tasks with persistent storage"

    on_enter:
      - action: inject_message
        content: |
          DECOMPOSITION PHASE

          Looking for a plan file matching: {{ plan_pattern }}
          Will break it into atomic, sequential tasks stored in Gobby.

      - action: read_artifact
        pattern: "{{ plan_pattern }}"
        as: current_plan

      - action: call_llm
        prompt: |
          Break this plan into atomic, sequential tasks.
          Each task should be:
          - Single responsibility (one file, one function, one test)
          - Independently verifiable
          - Ordered by dependency

          Plan:
          {{ current_plan }}

          Output as JSON: {"tasks": [{"id": 1, "title": "...", "verification": "..."}]}
        output_as: task_list

      # Persist tasks to database with ID mapping
      - action: persist_tasks
        source: task_list.tasks

      # Also write to TodoWrite for visibility
      - action: write_todos
        source: task_list.tasks

    allowed_tools:
      - Read
      - Glob
      - Grep
      - TodoWrite

    blocked_tools:
      - Edit
      - Write
      - Bash

    exit_conditions:
      - type: variable_set
        variable: task_list
      - type: user_approval
        prompt: "Proceed with these tasks?"

  - name: execute
    description: "Work through tasks sequentially"

    on_enter:
      - action: set_variable
        name: current_task_index
        value: 0

      # Load persisted tasks for this workflow
      - action: get_workflow_tasks
        as: workflow_tasks

      - action: inject_message
        content: |
          EXECUTION PHASE

          Working on task {{ current_task_index + 1 }} of {{ workflow_tasks | length }}.
          Focus on one task at a time. Say "done" or "next" when ready to verify.

    allowed_tools: all

    transitions:
      - to: verify
        when: "user_says('done') or user_says('next') or user_says('verify')"

  - name: verify
    description: "Verify current task completion"

    on_enter:
      - action: inject_message
        content: |
          VERIFICATION PHASE

          Verify the current task is complete.
          Run tests or checks, then confirm with "pass" or "fail".

    allowed_tools:
      - Read
      - Glob
      - Grep
      - Bash
      - TodoWrite

    blocked_tools:
      - Edit
      - Write

    transitions:
      - to: execute
        when: "user_says('pass') or user_says('verified')"
        on_transition:
          # Mark the task as complete in database
          - action: update_workflow_task
            status: closed
            validation_status: valid

          - action: mark_todo_complete
            index: "{{ current_task_index }}"

          - action: increment_variable
            name: current_task_index

      - to: complete
        when: "user_says('complete') or user_says('all done')"

      - to: execute
        when: "user_says('fail') or user_says('fix')"
        on_transition:
          - action: inject_message
            content: "Returning to execute phase to fix issues."

  - name: complete
    description: "All tasks complete"

    on_enter:
      - action: inject_message
        content: |
          ALL TASKS COMPLETE

          Great work! All planned tasks have been verified and stored.

triggers:
  on_session_start:
    - action: load_workflow_state

    # Try to load existing tasks for this workflow
    - action: get_workflow_tasks
      as: existing_tasks

    # Enter decompose if no tasks yet
    - action: enter_step
      step: decompose
      when: "not workflow_state.step and (not existing_tasks or existing_tasks | length == 0)"

    # Resume execution if tasks exist
    - action: enter_step
      step: execute
      when: "not workflow_state.step and existing_tasks and existing_tasks | length > 0"

  on_session_end:
    - action: save_workflow_state
